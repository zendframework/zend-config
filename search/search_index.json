{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-config zend-config is designed to simplify access to configuration data within applications. It provides a nested object property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of media supporting hierarchical data storage. File issues at https://github.com/zendframework/zend-config/issues Documentation is at https://docs.zendframework.com/zend-config/","title":"zend-config"},{"location":"#zend-config","text":"zend-config is designed to simplify access to configuration data within applications. It provides a nested object property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of media supporting hierarchical data storage. File issues at https://github.com/zendframework/zend-config/issues Documentation is at https://docs.zendframework.com/zend-config/","title":"zend-config"},{"location":"factory/","text":"The Factory Zend\\Config\\Factory provides the ability to load configuration files to an array or to a Zend\\Config\\Config object. The factory has two purposes Loading configuration file(s) Storing a configuration file Storage writes to a single file Storing the configuration always writes to a single file. The factory is not aware of merged configuration files, and as such cannot split configuration to multiple files. If you want to store particular configuration sections to separate files, you should separate them manually. Loading configuration files The first example illustrates loading a single configuration file: // Load a PHP file as array: $config = Zend\\Config\\Factory::fromFile(__DIR__ . '/config/my.config.php'); // Load an XML file as Config object; the second parameter, when true, // casts the configuration to a Config instance: $config = Zend\\Config\\Factory::fromFile(__DIR__.'/config/my.config.xml', true); The next example demonstrates merging multiple files; note that they are in separate formats! $config = Zend\\Config\\Factory::fromFiles([ __DIR__.'/config/my.config.php', __DIR__.'/config/my.config.xml', ]); Storing configuration Sometimes you may want to write configuration to a file. To do this, use the factory's toFile() method: $config = new Zend\\Config\\Config([], true); $config->settings = []; $config->settings->myname = 'framework'; $config->settings->date = '2012-12-12 12:12:12'; //Store the configuration Zend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config); //Store an array $config = [ 'settings' => [ 'myname' => 'framework', 'data' => '2012-12-12 12:12:12', ], ]; Zend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);","title":"Config Factory"},{"location":"factory/#the-factory","text":"Zend\\Config\\Factory provides the ability to load configuration files to an array or to a Zend\\Config\\Config object. The factory has two purposes Loading configuration file(s) Storing a configuration file","title":"The Factory"},{"location":"factory/#loading-configuration-files","text":"The first example illustrates loading a single configuration file: // Load a PHP file as array: $config = Zend\\Config\\Factory::fromFile(__DIR__ . '/config/my.config.php'); // Load an XML file as Config object; the second parameter, when true, // casts the configuration to a Config instance: $config = Zend\\Config\\Factory::fromFile(__DIR__.'/config/my.config.xml', true); The next example demonstrates merging multiple files; note that they are in separate formats! $config = Zend\\Config\\Factory::fromFiles([ __DIR__.'/config/my.config.php', __DIR__.'/config/my.config.xml', ]);","title":"Loading configuration files"},{"location":"factory/#storing-configuration","text":"Sometimes you may want to write configuration to a file. To do this, use the factory's toFile() method: $config = new Zend\\Config\\Config([], true); $config->settings = []; $config->settings->myname = 'framework'; $config->settings->date = '2012-12-12 12:12:12'; //Store the configuration Zend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config); //Store an array $config = [ 'settings' => [ 'myname' => 'framework', 'data' => '2012-12-12 12:12:12', ], ]; Zend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);","title":"Storing configuration"},{"location":"intro/","text":"Introduction zend-config is designed to simplify access to configuration data within applications. It provides a nested object, property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of formats supporting hierarchical data storage. Currently, zend-config provides adapters that read and write configuration data stored in INI, JSON, YAML, and XML files. Using Reader Classes Normally, users will use one of the reader classes to read a configuration file, but if configuration data is available in a PHP array, one may simply pass the data to Zend\\Config\\Config 's constructor in order to utilize a simple object-oriented interface: // An array of configuration data is given $configArray = [ 'webhost' => 'www.example.com', 'database' => [ 'adapter' => 'pdo_mysql', 'params' => [ 'host' => 'db.example.com', 'username' => 'dbuser', 'password' => 'secret', 'dbname' => 'mydatabase', ], ], ]; // Create the object-oriented wrapper using the configuration data $config = new Zend\\Config\\Config($configArray); // Print a configuration datum (results in 'www.example.com') echo $config->webhost; As illustrated in the example above, Zend\\Config\\Config provides nested object property syntax to access configuration data passed to its constructor. Along with the object-oriented access to the data values, Zend\\Config\\Config also has a get() method that accepts a default value to return if the data element requested doesn't exist in the configuration array. For example: $host = $config->database->get('host', 'localhost'); Using PHP Configuration Files PHP-based configuration files are often recommended due to the speed with which they are parsed, and the fact that they can be cached by opcode caches. The following code illustrates how to use PHP configuration files: Php Php // config.php return [ 'webhost' => 'www.example.com', 'database' => [ 'adapter' => 'pdo_mysql', 'params' => [ 'host' => 'db.example.com', 'username' => 'dbuser', 'password' => 'secret', 'dbname' => 'mydatabase', ], ], ]; // Consumes the configuration array $config = new Zend\\Config\\Config(include 'config.php'); // Print a configuration datum (results in 'www.example.com') echo $config->webhost;","title":"Introduction"},{"location":"intro/#introduction","text":"zend-config is designed to simplify access to configuration data within applications. It provides a nested object, property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of formats supporting hierarchical data storage. Currently, zend-config provides adapters that read and write configuration data stored in INI, JSON, YAML, and XML files.","title":"Introduction"},{"location":"intro/#using-reader-classes","text":"Normally, users will use one of the reader classes to read a configuration file, but if configuration data is available in a PHP array, one may simply pass the data to Zend\\Config\\Config 's constructor in order to utilize a simple object-oriented interface: // An array of configuration data is given $configArray = [ 'webhost' => 'www.example.com', 'database' => [ 'adapter' => 'pdo_mysql', 'params' => [ 'host' => 'db.example.com', 'username' => 'dbuser', 'password' => 'secret', 'dbname' => 'mydatabase', ], ], ]; // Create the object-oriented wrapper using the configuration data $config = new Zend\\Config\\Config($configArray); // Print a configuration datum (results in 'www.example.com') echo $config->webhost; As illustrated in the example above, Zend\\Config\\Config provides nested object property syntax to access configuration data passed to its constructor. Along with the object-oriented access to the data values, Zend\\Config\\Config also has a get() method that accepts a default value to return if the data element requested doesn't exist in the configuration array. For example: $host = $config->database->get('host', 'localhost');","title":"Using Reader Classes"},{"location":"intro/#using-php-configuration-files","text":"PHP-based configuration files are often recommended due to the speed with which they are parsed, and the fact that they can be cached by opcode caches. The following code illustrates how to use PHP configuration files: Php Php // config.php return [ 'webhost' => 'www.example.com', 'database' => [ 'adapter' => 'pdo_mysql', 'params' => [ 'host' => 'db.example.com', 'username' => 'dbuser', 'password' => 'secret', 'dbname' => 'mydatabase', ], ], ]; // Consumes the configuration array $config = new Zend\\Config\\Config(include 'config.php'); // Print a configuration datum (results in 'www.example.com') echo $config->webhost;","title":"Using PHP Configuration Files"},{"location":"processor/","text":"Zend\\Config\\Processor Zend\\Config\\Processor provides the ability to perform operations on a Zend\\Config\\Config object. Zend\\Config\\Processor is itself an interface that defining two methods: process() and processValue() . zend-config provides the following concrete implementations: Zend\\Config\\Processor\\Constant : manage PHP constant values. Zend\\Config\\Processor\\Filter : filter the configuration data using Zend\\Filter . Zend\\Config\\Processor\\Queue : manage a queue of operations to apply to configuration data. Zend\\Config\\Processor\\Token : find and replace specific tokens. Zend\\Config\\Processor\\Translator : translate configuration values in other languages using Zend\\I18n\\Translator . What gets processed? Typically, you will process configuration values . However, there are use cases for supplying constant and/or token keys ; one common one is for using class-based constants as keys to avoid using magic \"strings\": $$$$FENCED_CODE_BLOCK_5dbfef05a3bb67.12660385 As such, as of version 3.1.0, the Constant and Token processors can optionally also process the keys of the Config instance provided to them, by calling enableKeyProcessing() on their instances, or passing a boolean true value for the fourth constructor argument. Zend\\Config\\Processor\\Constant Using Zend\\Config\\Processor\\Constant This example illustrates the basic usage of Zend\\Config\\Processor\\Constant : define ('TEST_CONST', 'bar'); // Provide the second parameter as boolean true to allow modifications: $config = new Zend\\Config\\Config(['foo' => 'TEST_CONST'], true); $processor = new Zend\\Config\\Processor\\Constant(); echo $config->foo . ','; $processor->process($config); echo $config->foo; This example returns the output: TEST_CONST,bar . As of version 3.1.0, you can also tell the Constant processor to process keys: // At instantiation: $processor = new Zend\\Config\\Processor\\Constant(true, '', '', true); // Or later, via a method call: $processor->enableKeyProcessing(); When enabled, any constant values found in keys will also be replaced. Zend\\Config\\Processor\\Filter Using Zend\\Config\\Processor\\Filter This example illustrates basic usage of Zend\\Config\\Processor\\Filter : use Zend\\Filter\\StringToUpper; use Zend\\Config\\Processor\\Filter as FilterProcessor; use Zend\\Config\\Config; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['foo' => 'bar'], true); $upper = new StringToUpper(); $upperProcessor = new FilterProcessor($upper); echo $config->foo . ','; $upperProcessor->process($config); echo $config->foo; This example returns the output: bar,BAR . Zend\\Config\\Processor\\Queue Using Zend\\Config\\Processor\\Queue This example illustrates basic usage of Zend\\Config\\Processor\\Queue : use Zend\\Filter\\StringToLower; use Zend\\Filter\\StringToUpper; use Zend\\Config\\Processor\\Filter as FilterProcessor; use Zend\\Config\\Processor\\Queue; use Zend\\Config\\Config; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['foo' => 'bar'], true); $upper = new StringToUpper(); $lower = new StringToLower(); $lowerProcessor = new FilterProcessor($lower); $upperProcessor = new FilterProcessor($upper); $queue = new Queue(); $queue->insert($upperProcessor); $queue->insert($lowerProcessor); $queue->process($config); echo $config->foo; This example returns the output: bar . The filters in the queue are applied in FIFO (First In, First Out) order . Zend\\Config\\Processor\\Token Using Zend\\Config\\Processor\\Token This example illustrates basic usage of Zend\\Config\\Processor\\Token : use Zend\\Config\\Config; use Zend\\Config\\Processor\\Token as TokenProcessor; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['foo' => 'Value is TOKEN'], true); $processor = new TokenProcessor(); $processor->addToken('TOKEN', 'bar'); echo $config->foo . ','; $processor->process($config); echo $config->foo; This example returns the output: Value is TOKEN,Value is bar . As of version 3.1.0, you can also tell the Token processor to process keys: // At instantiation: $processor = new Zend\\Config\\Processor\\Token($tokens, '', '', true); // Or later, via a method call: $processor->enableKeyProcessing(); When enabled, any token values found in keys will also be replaced. Using Token processor as a simple environment processor Token processor can be utilized to populate config values using common format %env(ENV_VAR)% with values from environment by setting Token processor $prefix and $suffix parameters to %env( and )% respectively: use Zend\\Config\\Config; use Zend\\Config\\Processor\\Token as TokenProcessor; putenv('AMQP_PASSWORD=guest'); // Populate list if tokens to replace from environment: $processor = new TokenProcessor(getenv(), '%env(', ')%'); // Provide the second parameter as boolean true to allow modifications: $config = new Config([ 'host' => '127.0.0.1', 'port' => 5672, 'username' => '%env(AMQP_USER)%', 'password' => '%env(AMQP_PASSWORD)%', 'vhost' => '/', ], true); $processor->process($config); print_r($config->toArray()); // Array // ( // [host] => 127.0.0.1 // [port] => 5672 // [username] => %env(AMQP_USER)% // [password] => guest // [vhost] => / // ) Do note, however, that only values present in environment will be replaced. This allows multiple fallback processors to be provided as a queue. Zend\\Config\\Processor\\Translator Using Zend\\Config\\Processor\\Translator This example illustrates basic usage of Zend\\Config\\Processor\\Translator : use Zend\\Config\\Config; use Zend\\Config\\Processor\\Translator as TranslatorProcessor; use Zend\\I18n\\Translator\\Translator; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['animal' => 'dog'], true); /* * The following mapping is used for the translation * loader provided to the translator instance: * * $italian = [ * 'dog' => 'cane' * ]; */ $translator = new Translator(); // ... configure the translator ... $processor = new TranslatorProcessor($translator); echo \"English: {$config->animal}, \"; $processor->process($config); echo \"Italian: {$config->animal}\"; This example returns the output: English: dog,Italian: cane .","title":"Zend\\Config\\Processor"},{"location":"processor/#zend92config92processor","text":"Zend\\Config\\Processor provides the ability to perform operations on a Zend\\Config\\Config object. Zend\\Config\\Processor is itself an interface that defining two methods: process() and processValue() . zend-config provides the following concrete implementations: Zend\\Config\\Processor\\Constant : manage PHP constant values. Zend\\Config\\Processor\\Filter : filter the configuration data using Zend\\Filter . Zend\\Config\\Processor\\Queue : manage a queue of operations to apply to configuration data. Zend\\Config\\Processor\\Token : find and replace specific tokens. Zend\\Config\\Processor\\Translator : translate configuration values in other languages using Zend\\I18n\\Translator .","title":"Zend\\Config\\Processor"},{"location":"processor/#zend92config92processor92constant","text":"","title":"Zend\\Config\\Processor\\Constant"},{"location":"processor/#zend92config92processor92filter","text":"","title":"Zend\\Config\\Processor\\Filter"},{"location":"processor/#zend92config92processor92queue","text":"","title":"Zend\\Config\\Processor\\Queue"},{"location":"processor/#zend92config92processor92token","text":"","title":"Zend\\Config\\Processor\\Token"},{"location":"processor/#zend92config92processor92translator","text":"","title":"Zend\\Config\\Processor\\Translator"},{"location":"reader/","text":"Zend\\Config\\Reader Zend\\Config\\Reader gives you the ability to read a config file. It works with concrete implementations for different file formats. Zend\\Config\\Reader itself is only an interface, defining the methods fromFile() and fromString() . The concrete implementations of this interface are: Zend\\Config\\Reader\\Ini Zend\\Config\\Reader\\Xml Zend\\Config\\Reader\\Json Zend\\Config\\Reader\\Yaml Zend\\Config\\Reader\\JavaProperties fromFile() and fromString() are expected to return a PHP array containing the data from the specified configuration. Differences from ZF1 The Zend\\Config\\Reader component no longer supports the following features: Inheritance of sections. Reading of specific sections. Zend\\Config\\Reader\\Ini Zend\\Config\\Reader\\Ini enables developers to store configuration data in a familiar INI format, and then to read them in the application by using an array syntax. Zend\\Config\\Reader\\Ini utilizes the parse_ini_file() PHP function. Please review this documentation to be aware of its specific behaviors, which propagate to Zend\\Config\\Reader\\Ini , such as how the special values of TRUE , FALSE , \"yes\", \"no\", and NULL are handled. Key Separator By default, the key separator character is the period character ( . ). This can be changed, however, using the setNestSeparator() method. For example: $$$$FENCED_CODE_BLOCK_5dbfef05a40843.80592648 Process Sections By default, the INI reader executes parse_ini_file() with the optional parameter $process_sections being true . The result is a multidimensional array, with the section names and settings included. To merge sections, set the parameter via setProcessSections() to false as follows. $$$$FENCED_CODE_BLOCK_5dbfef05a40965.38861189 The following example illustrates basic usage of Zend\\Config\\Reader\\Ini for loading configuration data from an INI file. In this example, configuration data for both a production system and for a staging system exists. webhost = 'www.example.com' database.adapter = 'pdo_mysql' database.params.host = 'db.example.com' database.params.username = 'dbuser' database.params.password = 'secret' database.params.dbname = 'dbproduction' We can use Zend\\Config\\Reader\\Ini to read this INI file: $reader = new Zend\\Config\\Reader\\Ini(); $data = $reader->fromFile('/path/to/config.ini'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" Zend\\Config\\Reader\\Ini supports a feature to include the content of a INI file in a specific section of another INI file. For instance, suppose we have an INI file with the database configuration: database.adapter = 'pdo_mysql' database.params.host = 'db.example.com' database.params.username = 'dbuser' database.params.password = 'secret' database.params.dbname = 'dbproduction' We can include this configuration in another INI file by using the @include notation: webhost = 'www.example.com' @include = 'database.ini' If we read this file using the component Zend\\Config\\Reader\\Ini , we will obtain the same configuration data structure as in the previous example. The @include = 'file-to-include.ini' notation can be used also in a subelement of a value. For instance we can have an INI file like the following: adapter = 'pdo_mysql' params.host = 'db.example.com' params.username = 'dbuser' params.password = 'secret' params.dbname = 'dbproduction' And assign the @include as a subelement of the database value: webhost = 'www.example.com' database.@include = 'database.ini' Zend\\Config\\Reader\\Xml Zend\\Config\\Reader\\Xml enables developers to provide configuration data in a familiar XML format and consume it in the application using an array syntax. The root element of the XML file or string is irrelevant and may be named arbitrarily. The following example illustrates basic usage of Zend\\Config\\Reader\\Xml for loading configuration data from an XML file. First, our XML configuration in the file config.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> <webhost>www.example.com</webhost> <database> <adapter value=\"pdo_mysql\"/> <params> <host value=\"db.example.com\"/> <username value=\"dbuser\"/> <password value=\"secret\"/> <dbname value=\"dbproduction\"/> </params> </database> </config> We can use the Zend\\Config\\Reader\\Xml to read the XML configuration: $reader = new Zend\\Config\\Reader\\Xml(); $data = $reader->fromFile('/path/to/config.xml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']['value']; // prints \"dbproduction\" Zend\\Config\\Reader\\Xml utilizes PHP's XMLReader class. Please review its documentation to be aware of its specific behaviors, which propagate to Zend\\Config\\Reader\\Xml . Using Zend\\Config\\Reader\\Xml , we can include the content of XML files in a specific XML element. This is provided using the standard XInclude functionality of XML. To use this functionality, you must add the namespace xmlns:xi=\"http://www.w3.org/2001/XInclude\" to the XML file. Suppose we have an XML file that contains only the database configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> <database> <adapter>pdo_mysql</adapter> <params> <host>db.example.com</host> <username>dbuser</username> <password>secret</password> <dbname>dbproduction</dbname> </params> </database> </config> We can include this configuration in another XML file using an xinclude: <?xml version=\"1.0\" encoding=\"utf-8\"?> <config xmlns:xi=\"http://www.w3.org/2001/XInclude\"> <webhost>www.example.com</webhost> <xi:include href=\"database.xml\"/> </config> The syntax to include an XML file in a specific element is <xi:include href=\"file-to-include.xml\"/> Zend\\Config\\Reader\\Json Zend\\Config\\Reader\\Json enables developers to consume configuration data in JSON, and read it in the application by using an array syntax. The following example illustrates a basic use of Zend\\Config\\Reader\\Json for loading configuration data from a JSON file. Consider the following JSON configuration file: { \"webhost\" : \"www.example.com\", \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } We can use Zend\\Config\\Reader\\Json to read the file: $reader = new Zend\\Config\\Reader\\Json(); $data = $reader->fromFile('/path/to/config.json'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" Zend\\Config\\Reader\\Json utilizes zend-json . Using Zend\\Config\\Reader\\Json , we can include the content of a JSON file in a specific JSON section or element. This is provided using the special syntax @include . Suppose we have a JSON file that contains only the database configuration: { \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } Now let's include it via another configuration file: { \"webhost\" : \"www.example.com\", \"@include\" : \"database.json\" } Zend\\Config\\Reader\\Yaml Zend\\Config\\Reader\\Yaml enables developers to consume configuration data in a YAML format, and read them in the application by using an array syntax. In order to use the YAML reader, we need to pass a callback to an external PHP library or use the YAML PECL extension . The following example illustrates basic usage of Zend\\Config\\Reader\\Yaml , using the YAML PECL extension. Consider the following YAML file: webhost: www.example.com database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can use Zend\\Config\\Reader\\Yaml to read this YAML file: $reader = new Zend\\Config\\Reader\\Yaml(); $data = $reader->fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" If you want to use an external YAML reader, you must pass a callback function to the class constructor. For instance, if you want to use the Spyc library: // include the Spyc library require_once 'path/to/spyc.php'; $reader = new Zend\\Config\\Reader\\Yaml(['Spyc', 'YAMLLoadString']); $data = $reader->fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" You can also instantiate Zend\\Config\\Reader\\Yaml without any parameters, and specify the YAML reader using the setYamlDecoder() method. Using Zend\\Config\\ReaderYaml , we can include the content of another YAML file in a specific YAML section or element. This is provided using the special syntax @include . Consider the following YAML file containing only database configuration: database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can include this configuration in another YAML file: webhost: www.example.com @include: database.yaml Zend\\Config\\Reader\\JavaProperties Zend\\Config\\Reader\\JavaProperties enables developers to provide configuration data in the popular JavaProperties format, and read it in the application by using array syntax. The following example illustrates basic usage of Zend\\Config\\Reader\\JavaProperties for loading configuration data from a JavaProperties file. Suppose we have the following JavaProperties configuration file: #comment !comment webhost:www.example.com database.adapter:pdo_mysql database.params.host:db.example.com database.params.username:dbuser database.params.password:secret database.params.dbname:dbproduction We can use Zend\\Config\\Reader\\JavaProperties to read it: $reader = new Zend\\Config\\Reader\\JavaProperties(); $data = $reader->fromFile('/path/to/config.properties'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database.params.dbname']; // prints \"dbproduction\" Alternate delimiters Since 3.2.0 By default, the JavaProperties reader will assume that the delimiter between key/value pairs is : . If you wish to use an alternate delimiter, pass it as the first argument to the constructor: $reader = new JavaProperties('='); // Use = as the delimiter When specifying the default delimiter, you can use either : or the constant JavaProperties::DELIMITER_DEFAULT . Trimming whitespace Since 3.2.0 By default, whitespace is considered significant in JavaProperties files, including trailing whitespace. If you wish to have keys and values trimmed during parsing, you can pass a boolean true value, or the constant JavaProperties::WHITESPACE_TRIM , as the second argument to the constructor: $reader = new JavaProperties( JavaProperties::DELIMITER_DEFAULT, // use default delimiter JavaProperties::WHITESPACE_TRIM ); This can be useful particularly when surrounding the delimiter with whitespace: webhost = www.example.com database.adapter = pdo_mysql database.params.host = db.example.com database.params.username = dbuser database.params.password = secret database.params.dbname = dbproduction","title":"Zend\\Config\\Reader"},{"location":"reader/#zend92config92reader","text":"Zend\\Config\\Reader gives you the ability to read a config file. It works with concrete implementations for different file formats. Zend\\Config\\Reader itself is only an interface, defining the methods fromFile() and fromString() . The concrete implementations of this interface are: Zend\\Config\\Reader\\Ini Zend\\Config\\Reader\\Xml Zend\\Config\\Reader\\Json Zend\\Config\\Reader\\Yaml Zend\\Config\\Reader\\JavaProperties fromFile() and fromString() are expected to return a PHP array containing the data from the specified configuration.","title":"Zend\\Config\\Reader"},{"location":"reader/#zend92config92reader92ini","text":"Zend\\Config\\Reader\\Ini enables developers to store configuration data in a familiar INI format, and then to read them in the application by using an array syntax. Zend\\Config\\Reader\\Ini utilizes the parse_ini_file() PHP function. Please review this documentation to be aware of its specific behaviors, which propagate to Zend\\Config\\Reader\\Ini , such as how the special values of TRUE , FALSE , \"yes\", \"no\", and NULL are handled.","title":"Zend\\Config\\Reader\\Ini"},{"location":"reader/#zend92config92reader92xml","text":"Zend\\Config\\Reader\\Xml enables developers to provide configuration data in a familiar XML format and consume it in the application using an array syntax. The root element of the XML file or string is irrelevant and may be named arbitrarily. The following example illustrates basic usage of Zend\\Config\\Reader\\Xml for loading configuration data from an XML file. First, our XML configuration in the file config.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> <webhost>www.example.com</webhost> <database> <adapter value=\"pdo_mysql\"/> <params> <host value=\"db.example.com\"/> <username value=\"dbuser\"/> <password value=\"secret\"/> <dbname value=\"dbproduction\"/> </params> </database> </config> We can use the Zend\\Config\\Reader\\Xml to read the XML configuration: $reader = new Zend\\Config\\Reader\\Xml(); $data = $reader->fromFile('/path/to/config.xml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']['value']; // prints \"dbproduction\" Zend\\Config\\Reader\\Xml utilizes PHP's XMLReader class. Please review its documentation to be aware of its specific behaviors, which propagate to Zend\\Config\\Reader\\Xml . Using Zend\\Config\\Reader\\Xml , we can include the content of XML files in a specific XML element. This is provided using the standard XInclude functionality of XML. To use this functionality, you must add the namespace xmlns:xi=\"http://www.w3.org/2001/XInclude\" to the XML file. Suppose we have an XML file that contains only the database configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <config> <database> <adapter>pdo_mysql</adapter> <params> <host>db.example.com</host> <username>dbuser</username> <password>secret</password> <dbname>dbproduction</dbname> </params> </database> </config> We can include this configuration in another XML file using an xinclude: <?xml version=\"1.0\" encoding=\"utf-8\"?> <config xmlns:xi=\"http://www.w3.org/2001/XInclude\"> <webhost>www.example.com</webhost> <xi:include href=\"database.xml\"/> </config> The syntax to include an XML file in a specific element is <xi:include href=\"file-to-include.xml\"/>","title":"Zend\\Config\\Reader\\Xml"},{"location":"reader/#zend92config92reader92json","text":"Zend\\Config\\Reader\\Json enables developers to consume configuration data in JSON, and read it in the application by using an array syntax. The following example illustrates a basic use of Zend\\Config\\Reader\\Json for loading configuration data from a JSON file. Consider the following JSON configuration file: { \"webhost\" : \"www.example.com\", \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } We can use Zend\\Config\\Reader\\Json to read the file: $reader = new Zend\\Config\\Reader\\Json(); $data = $reader->fromFile('/path/to/config.json'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" Zend\\Config\\Reader\\Json utilizes zend-json . Using Zend\\Config\\Reader\\Json , we can include the content of a JSON file in a specific JSON section or element. This is provided using the special syntax @include . Suppose we have a JSON file that contains only the database configuration: { \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } Now let's include it via another configuration file: { \"webhost\" : \"www.example.com\", \"@include\" : \"database.json\" }","title":"Zend\\Config\\Reader\\Json"},{"location":"reader/#zend92config92reader92yaml","text":"Zend\\Config\\Reader\\Yaml enables developers to consume configuration data in a YAML format, and read them in the application by using an array syntax. In order to use the YAML reader, we need to pass a callback to an external PHP library or use the YAML PECL extension . The following example illustrates basic usage of Zend\\Config\\Reader\\Yaml , using the YAML PECL extension. Consider the following YAML file: webhost: www.example.com database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can use Zend\\Config\\Reader\\Yaml to read this YAML file: $reader = new Zend\\Config\\Reader\\Yaml(); $data = $reader->fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" If you want to use an external YAML reader, you must pass a callback function to the class constructor. For instance, if you want to use the Spyc library: // include the Spyc library require_once 'path/to/spyc.php'; $reader = new Zend\\Config\\Reader\\Yaml(['Spyc', 'YAMLLoadString']); $data = $reader->fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" You can also instantiate Zend\\Config\\Reader\\Yaml without any parameters, and specify the YAML reader using the setYamlDecoder() method. Using Zend\\Config\\ReaderYaml , we can include the content of another YAML file in a specific YAML section or element. This is provided using the special syntax @include . Consider the following YAML file containing only database configuration: database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can include this configuration in another YAML file: webhost: www.example.com @include: database.yaml","title":"Zend\\Config\\Reader\\Yaml"},{"location":"reader/#zend92config92reader92javaproperties","text":"Zend\\Config\\Reader\\JavaProperties enables developers to provide configuration data in the popular JavaProperties format, and read it in the application by using array syntax. The following example illustrates basic usage of Zend\\Config\\Reader\\JavaProperties for loading configuration data from a JavaProperties file. Suppose we have the following JavaProperties configuration file: #comment !comment webhost:www.example.com database.adapter:pdo_mysql database.params.host:db.example.com database.params.username:dbuser database.params.password:secret database.params.dbname:dbproduction We can use Zend\\Config\\Reader\\JavaProperties to read it: $reader = new Zend\\Config\\Reader\\JavaProperties(); $data = $reader->fromFile('/path/to/config.properties'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database.params.dbname']; // prints \"dbproduction\"","title":"Zend\\Config\\Reader\\JavaProperties"},{"location":"theory/","text":"Theory of Operation Configuration data are made accessible to Zend\\Config\\Config 's constructor via an associative array, which may be multi-dimensional so data can be organized from general to specific. Concrete adapter classes adapt configuration data from storage to produce the associative array for Zend\\Config\\Config 's constructor. If needed, user scripts may provide such arrays directly to Zend\\Config\\Config 's constructor, without using a reader class. Each value in the configuration data array becomes a property of the Zend\\Config\\Config object. The key is used as the property name. If a value is itself an array, then the resulting object property is created as a new Zend\\Config\\Config object, loaded with the array data. This occurs recursively, such that a hierarchy of configuration data may be created with any number of levels. Extending Zend\\Config\\Config class If you decide to extend Zend\\Config\\Config class, each property (subnode) becomes the same type as the parent class. For example: $$$$FENCED_CODE_BLOCK_5dbfef05a41911.87895887 This casting occurs in the constructor, which uses the construct new static() for any array subvalues it encounters when traversing the provided array. As such, we DO NOT RECOMMEND extending the constructor; instead, create a named constructor : $$$$FENCED_CODE_BLOCK_5dbfef05a41a15.81769609 Zend\\Config\\Config implements the Countable and Iterator interfaces in order to facilitate simple access to configuration data. Thus, Zend\\Config\\Config objects support the count() function and PHP constructs such as foreach . By default, configuration data made available through Zend\\Config\\Config are read-only, and an assignment (e.g., $config->database->host = 'example.com'; ) results in an exception. This default behavior may be overridden through the constructor, allowing modification of data values. Also, when modifications are allowed, Zend\\Config\\Config supports unsetting of values (e.g., unset($config->database->host) ). The isReadOnly() method can be used to determine if modifications to a given Zend\\Config\\Config object are allowed, and the setReadOnly() method can be used to stop any further modifications to a Zend\\Config\\Config object that was created allowing modifications. Modifying Config does not save changes It is important not to confuse such in-memory modifications with saving configuration data out to specific storage media. Tools for creating and modifying configuration data for various storage media are out of scope with respect to Zend\\Config\\Config . Third-party open source solutions are readily available for the purpose of creating and modifying configuration data for various storage media. If you have two Zend\\Config\\Config objects, you can merge them into a single object using the merge() function. For example, given $config and $localConfig , you can merge data from $localConfig to $config using $config->merge($localConfig); . The items in $localConfig will override any items with the same name in $config . Merging requires modifications The Zend\\Config\\Config object that is performing the merge must have been constructed to allow modifications, by passing TRUE as the second parameter of the constructor. The setReadOnly() method can then be used to prevent any further modifications after the merge is complete.","title":"Theory of Operation"},{"location":"theory/#theory-of-operation","text":"Configuration data are made accessible to Zend\\Config\\Config 's constructor via an associative array, which may be multi-dimensional so data can be organized from general to specific. Concrete adapter classes adapt configuration data from storage to produce the associative array for Zend\\Config\\Config 's constructor. If needed, user scripts may provide such arrays directly to Zend\\Config\\Config 's constructor, without using a reader class. Each value in the configuration data array becomes a property of the Zend\\Config\\Config object. The key is used as the property name. If a value is itself an array, then the resulting object property is created as a new Zend\\Config\\Config object, loaded with the array data. This occurs recursively, such that a hierarchy of configuration data may be created with any number of levels.","title":"Theory of Operation"},{"location":"writer/","text":"Zend\\Config\\Writer Zend\\Config\\Writer provides the ability to write config files from an array, Zend\\Config\\Config instance, or any Traversable object. Zend\\Config\\Writer is itself only an interface that defining the methods toFile() and toString() . We have six writers implementing the interface: Zend\\Config\\Writer\\Ini Zend\\Config\\Writer\\JavaProperties Zend\\Config\\Writer\\Json Zend\\Config\\Writer\\PhpArray Zend\\Config\\Writer\\Xml Zend\\Config\\Writer\\Yaml Zend\\Config\\Writer\\Ini The INI writer has two modes for rendering with regard to sections. By default, the top-level configuration is always written into section names. By calling $writer->setRenderWithoutSectionsFlags(true); all options are written into the global namespace of the INI file and no sections are applied. Zend\\Config\\Writer\\Ini has an additional option parameter, nestSeparator , which defines with which character the single nodes are separated. The default is a single dot ( . ), such as is accepted by Zend\\Config\\Reader\\Ini by default. When modifying or creating a Zend\\Config\\Config object, there are several considerations to keep in mind. To create or modify a value, you simply say set the parameter of the Config object via the parameter accessor ( -> ). To create a section in the root or to create a branch, just create a new array ( $config->branch = []; ). Using Zend\\Config\\Writer\\Ini Consider the following code, which creates a configuration structure: // Create the config object $config = new Zend\\Config\\Config([], true); $config->production = []; $config->production->webhost = 'www.example.com'; $config->production->database = []; $config->production->database->params = []; $config->production->database->params->host = 'localhost'; $config->production->database->params->username = 'production'; $config->production->database->params->password = 'secret'; $config->production->database->params->dbname = 'dbproduction'; $writer = new Zend\\Config\\Writer\\Ini(); echo $writer->toString($config); The result of this code is the following INI string: [production] webhost = \"www.example.com\" database.params.host = \"localhost\" database.params.username = \"production\" database.params.password = \"secret\" database.params.dbname = \"dbproduction\" You can use the method toFile() to store the INI data to a file instead. Zend\\Config\\Writer\\JavaProperties Since 3.2.0 The JavaProperties writer can only write single-dimensional configuration (i.e., key/value pairs); this is a limitation of the JavaProperties format. Zend\\Config\\Writer\\JavaProperties has a single, optional constructor parameter, delimiter , which defines with which character the key/value pairs are separated. The default is a single colon ( : ), such as is accepted by Zend\\Config\\Reader\\JavaProperties by default. Using Zend\\Config\\Writer\\JavaProperties Consider the following code, creating configuration: // Create the config object $config = new Zend\\Config\\Config([], true); $config->webhost = 'www.example.com'; // use object notation $config['database.host'] = 'localhost'; // or array notation, for complex key names $config['database.username'] = 'production'; $config['database.password'] = 'secret'; $config['database.dbname'] = 'dbproduction'; $writer = new Zend\\Config\\Writer\\JavaProperties(); echo $writer->toString($config); The result of this code is the following JavaProperties string: webhost:www.example.com database.host:localhost database.username:production database.password:secret database.dbname:dbproduction You can use the method toFile() to store the JavaProperties data to a file instead. Using an alternate delimiter If you want to use an alternate delimiter, such as = , pass it to the constructor: $writer = new Zend\\Config\\Writer\\JavaProperties('='); Using the above configuration, we would now receive: webhost=www.example.com database.host=localhost database.username=production database.password=secret database.dbname=dbproduction Zend\\Config\\Writer\\Xml Zend\\Config\\Writer\\Xml can be used to generate an XML string or file. Using Zend\\Config\\Writer\\Xml Consider the following code, which creates a configuration structure: // Create the config object $config = new Zend\\Config\\Config([], true); $config->production = []; $config->production->webhost = 'www.example.com'; $config->production->database = []; $config->production->database->params = []; $config->production->database->params->host = 'localhost'; $config->production->database->params->username = 'production'; $config->production->database->params->password = 'secret'; $config->production->database->params->dbname = 'dbproduction'; $writer = new Zend\\Config\\Writer\\Xml(); echo $writer->toString($config); The result of this code is the following XML string: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <zend-config> <production> <webhost>www.example.com</webhost> <database> <params> <host>localhost</host> <username>production</username> <password>secret</password> <dbname>dbproduction</dbname> </params> </database> </production> </zend-config> You can use the method toFile() to store the XML data to a file. Zend\\Config\\Writer\\PhpArray Zend\\Config\\Writer\\PhpArray can be used to generate a PHP script that represents and returns configuration. Using Zend\\Config\\Writer\\PhpArray Consider the following code, which creates a configuration structure: // Create the config object $config = new Zend\\Config\\Config([], true); $config->production = []; $config->production->webhost = 'www.example.com'; $config->production->database = []; $config->production->database->params = []; $config->production->database->params->host = 'localhost'; $config->production->database->params->username = 'production'; $config->production->database->params->password = 'secret'; $config->production->database->params->dbname = 'dbproduction'; $writer = new Zend\\Config\\Writer\\PhpArray(); echo $writer->toString($config); The result of this code is the following PHP script: <?php return [ 'production' => [ 'webhost' => 'www.example.com', 'database' => [ 'params' => [ 'host' => 'localhost', 'username' => 'production', 'password' => 'secret', 'dbname' => 'dbproduction', ], ], ], ]; You can use the method toFile() to save the PHP script to a file. Zend\\Config\\Writer\\Json Zend\\Config\\Writer\\Json can be used to generate a JSON representation of configuration. Using Zend\\Config\\Writer\\Json Consider the following code, which creates a configuration structure: // Create the config object $config = new Zend\\Config\\Config([], true); $config->production = []; $config->production->webhost = 'www.example.com'; $config->production->database = []; $config->production->database->params = []; $config->production->database->params->host = 'localhost'; $config->production->database->params->username = 'production'; $config->production->database->params->password = 'secret'; $config->production->database->params->dbname = 'dbproduction'; $writer = new Zend\\Config\\Writer\\Json(); echo $writer->toString($config); The result of this code is the following JSON string: { \"webhost\": \"www.example.com\", \"database\": { \"params\": { \"host\": \"localhost\", \"username\": \"production\", \"password\": \"secret\", \"dbname\": \"dbproduction\" } } } You can use the method toFile() to save the JSON data to a file. Zend\\Config\\Writer\\Json uses the zend-json component to convert the data to JSON. Zend\\Config\\Writer\\Yaml Zend\\Config\\Writer\\Yaml can be used to generate a PHP code that returns the YAML representation of configuration. In order to use the YAML writer, we need to pass a callback to an external PHP library, or use the YAML PECL extension . Using Zend\\Config\\Writer\\Yaml Consider the following code, which creates a configuration structure using the YAML PECL extension: // Create the config object $config = new Zend\\Config\\Config([], true); $config->production = []; $config->production->webhost = 'www.example.com'; $config->production->database = []; $config->production->database->params = []; $config->production->database->params->host = 'localhost'; $config->production->database->params->username = 'production'; $config->production->database->params->password = 'secret'; $config->production->database->params->dbname = 'dbproduction'; $writer = new Zend\\Config\\Writer\\Yaml(); echo $writer->toString($config); The result of this code is the following YAML string contains the following value: webhost: www.example.com database: params: host: localhost username: production password: secret dbname: dbproduction You can use the method toFile() to save the YAML data to a file. If you want to use an external YAML writer library, pass the callback function that will generate the YAML from the configuration when instantiating the writer. For instance, to use the Spyc library: // include the Spyc library require_once 'path/to/spyc.php'; $writer = new Zend\\Config\\Writer\\Yaml(['Spyc', 'YAMLDump']); echo $writer->toString($config);","title":"Zend\\Config\\Writer"},{"location":"writer/#zend92config92writer","text":"Zend\\Config\\Writer provides the ability to write config files from an array, Zend\\Config\\Config instance, or any Traversable object. Zend\\Config\\Writer is itself only an interface that defining the methods toFile() and toString() . We have six writers implementing the interface: Zend\\Config\\Writer\\Ini Zend\\Config\\Writer\\JavaProperties Zend\\Config\\Writer\\Json Zend\\Config\\Writer\\PhpArray Zend\\Config\\Writer\\Xml Zend\\Config\\Writer\\Yaml","title":"Zend\\Config\\Writer"},{"location":"writer/#zend92config92writer92ini","text":"The INI writer has two modes for rendering with regard to sections. By default, the top-level configuration is always written into section names. By calling $writer->setRenderWithoutSectionsFlags(true); all options are written into the global namespace of the INI file and no sections are applied. Zend\\Config\\Writer\\Ini has an additional option parameter, nestSeparator , which defines with which character the single nodes are separated. The default is a single dot ( . ), such as is accepted by Zend\\Config\\Reader\\Ini by default. When modifying or creating a Zend\\Config\\Config object, there are several considerations to keep in mind. To create or modify a value, you simply say set the parameter of the Config object via the parameter accessor ( -> ). To create a section in the root or to create a branch, just create a new array ( $config->branch = []; ).","title":"Zend\\Config\\Writer\\Ini"},{"location":"writer/#zend92config92writer92javaproperties","text":"Since 3.2.0 The JavaProperties writer can only write single-dimensional configuration (i.e., key/value pairs); this is a limitation of the JavaProperties format. Zend\\Config\\Writer\\JavaProperties has a single, optional constructor parameter, delimiter , which defines with which character the key/value pairs are separated. The default is a single colon ( : ), such as is accepted by Zend\\Config\\Reader\\JavaProperties by default.","title":"Zend\\Config\\Writer\\JavaProperties"},{"location":"writer/#zend92config92writer92xml","text":"Zend\\Config\\Writer\\Xml can be used to generate an XML string or file.","title":"Zend\\Config\\Writer\\Xml"},{"location":"writer/#zend92config92writer92phparray","text":"Zend\\Config\\Writer\\PhpArray can be used to generate a PHP script that represents and returns configuration.","title":"Zend\\Config\\Writer\\PhpArray"},{"location":"writer/#zend92config92writer92json","text":"Zend\\Config\\Writer\\Json can be used to generate a JSON representation of configuration.","title":"Zend\\Config\\Writer\\Json"},{"location":"writer/#zend92config92writer92yaml","text":"Zend\\Config\\Writer\\Yaml can be used to generate a PHP code that returns the YAML representation of configuration. In order to use the YAML writer, we need to pass a callback to an external PHP library, or use the YAML PECL extension .","title":"Zend\\Config\\Writer\\Yaml"},{"location":"migration/to-v3/","text":"Migration to version 3 Version 3 is essentially fully backwards compatible with previous versions, with one key exception: Zend\\Config\\Factory no longer requires usage of zend-servicemanager for resolving plugins. The reason this is considered a backwards compatibility break is due to signature changes: Factory::setReaderPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Zend\\Config\\ReaderPluginManager instance; ReaderPluginManager , however, still fulfills that typehint. Factory::getReaderPluginManager() now returns a Psr\\Container\\ContainerInterface \u2014 specifically, a Zend\\Config\\StandaloneReaderPluginManager \u2014 and not a Zend\\Config\\ReaderPluginManager instance, by default; ReaderPluginManager , however, still fulfills that typehint. Factory::setWriterPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Zend\\Config\\WriterPluginManager instance; WriterPluginManager , however, still fulfills that typehint. Factory::getWriterPluginManager() now returns a Psr\\Container\\ContainerInterface \u2014 specifically, a Zend\\Config\\StandaloneWriterPluginManager \u2014 and not a Zend\\Config\\WriterPluginManager instance, by default; WriterPluginManager , however, still fulfills that typehint. If you were extending the class, you will need to update your signatures accordingly. This particular update means that you may use any PSR-11 container as a reader or writer plugin manager, and no longer require installation of zend-servicemanager to use the plugin manager facilities.","title":"To version 3"},{"location":"migration/to-v3/#migration-to-version-3","text":"Version 3 is essentially fully backwards compatible with previous versions, with one key exception: Zend\\Config\\Factory no longer requires usage of zend-servicemanager for resolving plugins. The reason this is considered a backwards compatibility break is due to signature changes: Factory::setReaderPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Zend\\Config\\ReaderPluginManager instance; ReaderPluginManager , however, still fulfills that typehint. Factory::getReaderPluginManager() now returns a Psr\\Container\\ContainerInterface \u2014 specifically, a Zend\\Config\\StandaloneReaderPluginManager \u2014 and not a Zend\\Config\\ReaderPluginManager instance, by default; ReaderPluginManager , however, still fulfills that typehint. Factory::setWriterPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Zend\\Config\\WriterPluginManager instance; WriterPluginManager , however, still fulfills that typehint. Factory::getWriterPluginManager() now returns a Psr\\Container\\ContainerInterface \u2014 specifically, a Zend\\Config\\StandaloneWriterPluginManager \u2014 and not a Zend\\Config\\WriterPluginManager instance, by default; WriterPluginManager , however, still fulfills that typehint. If you were extending the class, you will need to update your signatures accordingly. This particular update means that you may use any PSR-11 container as a reader or writer plugin manager, and no longer require installation of zend-servicemanager to use the plugin manager facilities.","title":"Migration to version 3"}]}