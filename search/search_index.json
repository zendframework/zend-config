{
    "docs": [
        {
            "location": "/",
            "text": "zend-config\n\n\n\n\n\n\nzend-config is designed to simplify access to configuration data within\napplications. It provides a nested object property-based user interface for\naccessing this configuration data within application code. The configuration\ndata may come from a variety of media supporting hierarchical data storage.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-config/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-config/",
            "title": "zend-config"
        },
        {
            "location": "/#zend-config",
            "text": "zend-config is designed to simplify access to configuration data within\napplications. It provides a nested object property-based user interface for\naccessing this configuration data within application code. The configuration\ndata may come from a variety of media supporting hierarchical data storage.   File issues at https://github.com/zendframework/zend-config/issues  Documentation is at https://docs.zendframework.com/zend-config/",
            "title": "zend-config"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-config is designed to simplify access to configuration data within applications. It provides\na nested object, property-based user interface for accessing this configuration data within\napplication code. The configuration data may come from a variety of formats supporting hierarchical\ndata storage. Currently, zend-config provides adapters that read and write configuration data\nstored in INI, JSON, YAML, and XML files.\n\n\nUsing Reader Classes\n\n\nNormally, users will use one of the \nreader classes\n to read a\nconfiguration file, but if configuration data is available in a PHP array, one\nmay simply pass the data to \nZend\\Config\\Config\n's constructor in order to\nutilize a simple object-oriented interface:\n\n\n// An array of configuration data is given\n$configArray = [\n    'webhost'  => 'www.example.com',\n    'database' => [\n        'adapter' => 'pdo_mysql',\n        'params'  => [\n            'host'     => 'db.example.com',\n            'username' => 'dbuser',\n            'password' => 'secret',\n            'dbname'   => 'mydatabase',\n        ],\n    ],\n];\n\n// Create the object-oriented wrapper using the configuration data\n$config = new Zend\\Config\\Config($configArray);\n\n// Print a configuration datum (results in 'www.example.com')\necho $config->webhost;\n\n\n\nAs illustrated in the example above, \nZend\\Config\\Config\n provides nested object\nproperty syntax to access configuration data passed to its constructor.\n\n\nAlong with the object-oriented access to the data values, \nZend\\Config\\Config\n\nalso has a \nget()\n method that accepts a default value to return if the data\nelement requested doesn't exist in the configuration array. For example:\n\n\n$host = $config->database->get('host', 'localhost');\n\n\n\nUsing PHP Configuration Files\n\n\nPHP-based configuration files are often recommended due to the speed with which\nthey are parsed, and the fact that they can be cached by opcode caches.\n\n\nThe following code illustrates how to use PHP configuration files:\n\n\n// config.php\nreturn [\n    'webhost'  => 'www.example.com',\n    'database' => [\n        'adapter' => 'pdo_mysql',\n        'params'  => [\n            'host'     => 'db.example.com',\n            'username' => 'dbuser',\n            'password' => 'secret',\n            'dbname'   => 'mydatabase',\n        ],\n    ],\n];\n\n\n\n// Consumes the configuration array\n$config = new Zend\\Config\\Config(include 'config.php');\n\n// Print a configuration datum (results in 'www.example.com')\necho $config->webhost;",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-config is designed to simplify access to configuration data within applications. It provides\na nested object, property-based user interface for accessing this configuration data within\napplication code. The configuration data may come from a variety of formats supporting hierarchical\ndata storage. Currently, zend-config provides adapters that read and write configuration data\nstored in INI, JSON, YAML, and XML files.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#using-reader-classes",
            "text": "Normally, users will use one of the  reader classes  to read a\nconfiguration file, but if configuration data is available in a PHP array, one\nmay simply pass the data to  Zend\\Config\\Config 's constructor in order to\nutilize a simple object-oriented interface:  // An array of configuration data is given\n$configArray = [\n    'webhost'  => 'www.example.com',\n    'database' => [\n        'adapter' => 'pdo_mysql',\n        'params'  => [\n            'host'     => 'db.example.com',\n            'username' => 'dbuser',\n            'password' => 'secret',\n            'dbname'   => 'mydatabase',\n        ],\n    ],\n];\n\n// Create the object-oriented wrapper using the configuration data\n$config = new Zend\\Config\\Config($configArray);\n\n// Print a configuration datum (results in 'www.example.com')\necho $config->webhost;  As illustrated in the example above,  Zend\\Config\\Config  provides nested object\nproperty syntax to access configuration data passed to its constructor.  Along with the object-oriented access to the data values,  Zend\\Config\\Config \nalso has a  get()  method that accepts a default value to return if the data\nelement requested doesn't exist in the configuration array. For example:  $host = $config->database->get('host', 'localhost');",
            "title": "Using Reader Classes"
        },
        {
            "location": "/intro/#using-php-configuration-files",
            "text": "PHP-based configuration files are often recommended due to the speed with which\nthey are parsed, and the fact that they can be cached by opcode caches.  The following code illustrates how to use PHP configuration files:  // config.php\nreturn [\n    'webhost'  => 'www.example.com',\n    'database' => [\n        'adapter' => 'pdo_mysql',\n        'params'  => [\n            'host'     => 'db.example.com',\n            'username' => 'dbuser',\n            'password' => 'secret',\n            'dbname'   => 'mydatabase',\n        ],\n    ],\n];  // Consumes the configuration array\n$config = new Zend\\Config\\Config(include 'config.php');\n\n// Print a configuration datum (results in 'www.example.com')\necho $config->webhost;",
            "title": "Using PHP Configuration Files"
        },
        {
            "location": "/theory/",
            "text": "Theory of Operation\n\n\nConfiguration data are made accessible to \nZend\\Config\\Config\n's constructor via\nan associative array, which may be multi-dimensional so data can be organized\nfrom general to specific. Concrete adapter classes adapt configuration data from\nstorage to produce the associative array for \nZend\\Config\\Config\n's constructor.\nIf needed, user scripts may provide such arrays directly to\n\nZend\\Config\\Config\n's constructor, without using a reader class.\n\n\nEach value in the configuration data array becomes a property of the\n\nZend\\Config\\Config\n object.  The key is used as the property name. If a value\nis itself an array, then the resulting object property is created as a new\n\nZend\\Config\\Config\n object, loaded with the array data. This occurs\nrecursively, such that a hierarchy of configuration data may be created with any\nnumber of levels.\n\n\nZend\\Config\\Config\n implements the \nCountable\n\nand \nIterator\n interfaces in order\nto facilitate simple access to configuration data. Thus, \nZend\\Config\\Config\n\nobjects support the \ncount()\n function and PHP constructs\nsuch as \nforeach\n.\n\n\nBy default, configuration data made available through \nZend\\Config\\Config\n are\nread-only, and an assignment (e.g., \n$config->database->host = 'example.com';\n)\nresults in an exception. This default behavior may be overridden through the\nconstructor, allowing modification of data values.  Also, when modifications are\nallowed, \nZend\\Config\\Config\n supports unsetting of values (e.g.,\n\nunset($config->database->host)\n). The \nisReadOnly()\n method can be used to\ndetermine if modifications to a given \nZend\\Config\\Config\n object are allowed,\nand the \nsetReadOnly()\n method can be used to stop any further modifications to\na \nZend\\Config\\Config\n object that was created allowing modifications.\n\n\n\n\nModifying Config does not save changes\n\n\nIt is important not to confuse such in-memory modifications with saving\nconfiguration data out to specific storage media. Tools for creating and\nmodifying configuration data for various storage media are out of scope with\nrespect to \nZend\\Config\\Config\n. Third-party open source solutions are readily\navailable for the purpose of creating and modifying configuration data for\nvarious storage media.\n\n\n\n\nIf you have two \nZend\\Config\\Config\n objects, you can merge them into a single\nobject using the \nmerge()\n function. For example, given \n$config\n and\n\n$localConfig\n, you can merge data from \n$localConfig\n to \n$config\n using\n\n$config->merge($localConfig);\n. The items in \n$localConfig\n will override any\nitems with the same name in \n$config\n.\n\n\n\n\nMerging requires modifications\n\n\nThe \nZend\\Config\\Config\n object that is performing the merge must have been\nconstructed to allow modifications, by passing \nTRUE\n as the second parameter\nof the constructor. The \nsetReadOnly()\n method can then be used to prevent any\nfurther modifications after the merge is complete.",
            "title": "Theory of Operation"
        },
        {
            "location": "/theory/#theory-of-operation",
            "text": "Configuration data are made accessible to  Zend\\Config\\Config 's constructor via\nan associative array, which may be multi-dimensional so data can be organized\nfrom general to specific. Concrete adapter classes adapt configuration data from\nstorage to produce the associative array for  Zend\\Config\\Config 's constructor.\nIf needed, user scripts may provide such arrays directly to Zend\\Config\\Config 's constructor, without using a reader class.  Each value in the configuration data array becomes a property of the Zend\\Config\\Config  object.  The key is used as the property name. If a value\nis itself an array, then the resulting object property is created as a new Zend\\Config\\Config  object, loaded with the array data. This occurs\nrecursively, such that a hierarchy of configuration data may be created with any\nnumber of levels.  Zend\\Config\\Config  implements the  Countable \nand  Iterator  interfaces in order\nto facilitate simple access to configuration data. Thus,  Zend\\Config\\Config \nobjects support the  count()  function and PHP constructs\nsuch as  foreach .  By default, configuration data made available through  Zend\\Config\\Config  are\nread-only, and an assignment (e.g.,  $config->database->host = 'example.com'; )\nresults in an exception. This default behavior may be overridden through the\nconstructor, allowing modification of data values.  Also, when modifications are\nallowed,  Zend\\Config\\Config  supports unsetting of values (e.g., unset($config->database->host) ). The  isReadOnly()  method can be used to\ndetermine if modifications to a given  Zend\\Config\\Config  object are allowed,\nand the  setReadOnly()  method can be used to stop any further modifications to\na  Zend\\Config\\Config  object that was created allowing modifications.",
            "title": "Theory of Operation"
        },
        {
            "location": "/theory/#modifying-config-does-not-save-changes",
            "text": "It is important not to confuse such in-memory modifications with saving\nconfiguration data out to specific storage media. Tools for creating and\nmodifying configuration data for various storage media are out of scope with\nrespect to  Zend\\Config\\Config . Third-party open source solutions are readily\navailable for the purpose of creating and modifying configuration data for\nvarious storage media.   If you have two  Zend\\Config\\Config  objects, you can merge them into a single\nobject using the  merge()  function. For example, given  $config  and $localConfig , you can merge data from  $localConfig  to  $config  using $config->merge($localConfig); . The items in  $localConfig  will override any\nitems with the same name in  $config .",
            "title": "Modifying Config does not save changes"
        },
        {
            "location": "/theory/#merging-requires-modifications",
            "text": "The  Zend\\Config\\Config  object that is performing the merge must have been\nconstructed to allow modifications, by passing  TRUE  as the second parameter\nof the constructor. The  setReadOnly()  method can then be used to prevent any\nfurther modifications after the merge is complete.",
            "title": "Merging requires modifications"
        },
        {
            "location": "/reader/",
            "text": "Zend\\Config\\Reader\n\n\nZend\\Config\\Reader\n gives you the ability to read a config file. It works with\nconcrete implementations for different file formats. \nZend\\Config\\Reader\n itself\nis only an interface, defining the methods \nfromFile()\n and \nfromString()\n. The\nconcrete implementations of this interface are:\n\n\n\n\nZend\\Config\\Reader\\Ini\n\n\nZend\\Config\\Reader\\Xml\n\n\nZend\\Config\\Reader\\Json\n\n\nZend\\Config\\Reader\\Yaml\n\n\nZend\\Config\\Reader\\JavaProperties\n\n\n\n\nfromFile()\n and \nfromString()\n are expected to return a PHP array containing\nthe data from the specified configuration.\n\n\n\n\nDifferences from ZF1\n\n\nThe \nZend\\Config\\Reader\n component no longer supports the following features:\n\n\n\n\nInheritance of sections.\n\n\nReading of specific sections.\n\n\n\n\n\n\nZend\\Config\\Reader\\Ini\n\n\nZend\\Config\\Reader\\Ini\n enables developers to store configuration data in a\nfamiliar INI format, and then to read them in the application by using an array\nsyntax.\n\n\nZend\\Config\\Reader\\Ini\n utilizes the \nparse_ini_file()\n PHP\nfunction. Please review this documentation to be aware of its specific behaviors, which propagate to\n\nZend\\Config\\Reader\\Ini\n, such as how the special values of \nTRUE\n, \nFALSE\n, \"yes\", \"no\", and\n\nNULL\n are handled.\n\n\n\n\nKey Separator\n\n\nBy default, the key separator character is the period character (\n.\n). This can be changed,\nhowever, using the \nsetNestSeparator()\n method. For example:\n\n\n$reader = new Zend\\Config\\Reader\\Ini();\n$reader-setNestSeparator('-');\n\n\n\n\n\nThe following example illustrates basic usage of \nZend\\Config\\Reader\\Ini\n for\nloading configuration data from an INI file. In this example, configuration data\nfor both a production system and for a staging system exists.\n\n\nwebhost                  = 'www.example.com'\ndatabase.adapter         = 'pdo_mysql'\ndatabase.params.host     = 'db.example.com'\ndatabase.params.username = 'dbuser'\ndatabase.params.password = 'secret'\ndatabase.params.dbname   = 'dbproduction'\n\n\n\nWe can use \nZend\\Config\\Reader\\Ini\n to read this INI file:\n\n\n$reader = new Zend\\Config\\Reader\\Ini();\n$data   = $reader->fromFile('/path/to/config.ini');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"\n\n\n\nZend\\Config\\Reader\\Ini\n supports a feature to include the content of a INI file\nin a specific section of another INI file. For instance, suppose we have an INI\nfile with the database configuration:\n\n\ndatabase.adapter         = 'pdo_mysql'\ndatabase.params.host     = 'db.example.com'\ndatabase.params.username = 'dbuser'\ndatabase.params.password = 'secret'\ndatabase.params.dbname   = 'dbproduction'\n\n\n\nWe can include this configuration in another INI file by using the \n@include\n\nnotation:\n\n\nwebhost  = 'www.example.com'\n@include = 'database.ini'\n\n\n\nIf we read this file using the component \nZend\\Config\\Reader\\Ini\n, we will obtain the same\nconfiguration data structure as in the previous example.\n\n\nThe \n@include = 'file-to-include.ini'\n notation can be used also in a subelement\nof a value. For instance we can have an INI file like the following:\n\n\nadapter         = 'pdo_mysql'\nparams.host     = 'db.example.com'\nparams.username = 'dbuser'\nparams.password = 'secret'\nparams.dbname   = 'dbproduction'\n\n\n\nAnd assign the \n@include\n as a subelement of the \ndatabase\n value:\n\n\nwebhost           = 'www.example.com'\ndatabase.@include = 'database.ini'\n\n\n\nZend\\Config\\Reader\\Xml\n\n\nZend\\Config\\Reader\\Xml\n enables developers to provide configuration data in a\nfamiliar XML format and consume it in the application using an array syntax.\nThe root element of the XML file or string is irrelevant and may be named\narbitrarily.\n\n\nThe following example illustrates basic usage of \nZend\\Config\\Reader\\Xml\n for loading configuration\ndata from an XML file. First, our XML configuration in the file \nconfig.xml\n:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<config>\n    <webhost>www.example.com</webhost>\n    <database>\n        <adapter value=\"pdo_mysql\"/>\n        <params>\n            <host value=\"db.example.com\"/>\n            <username value=\"dbuser\"/>\n            <password value=\"secret\"/>\n            <dbname value=\"dbproduction\"/>\n        </params>\n    </database>\n</config>\n\n\n\nWe can use the \nZend\\Config\\Reader\\Xml\n to read the XML configuration:\n\n\n$reader = new Zend\\Config\\Reader\\Xml();\n$data   = $reader->fromFile('/path/to/config.xml');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname']['value'];  // prints \"dbproduction\"\n\n\n\nZend\\Config\\Reader\\Xml\n utilizes PHP's \nXMLReader\n class. Please\nreview its documentation to be aware of its specific behaviors, which propagate to\n\nZend\\Config\\Reader\\Xml\n.\n\n\nUsing \nZend\\Config\\Reader\\Xml\n, we can include the content of XML files in a\nspecific XML element.  This is provided using the standard\n\nXInclude\n functionality of XML. To use this\nfunctionality, you must add the namespace\n\nxmlns:xi=\"http://www.w3.org/2001/XInclude\"\n to the XML file.\n\n\nSuppose we have an XML file that contains only the database configuration:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<config>\n    <database>\n        <adapter>pdo_mysql</adapter>\n        <params>\n            <host>db.example.com</host>\n            <username>dbuser</username>\n            <password>secret</password>\n            <dbname>dbproduction</dbname>\n        </params>\n    </database>\n</config>\n\n\n\nWe can include this configuration in another XML file using an xinclude:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<config xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n    <webhost>www.example.com</webhost>\n    <xi:include href=\"database.xml\"/>\n</config>\n\n\n\nThe syntax to include an XML file in a specific element is \n<xi:include\nhref=\"file-to-include.xml\"/>\n\n\nZend\\Config\\Reader\\Json\n\n\nZend\\Config\\Reader\\Json\n enables developers to consume configuration data in\nJSON, and read it in the application by using an array syntax.\n\n\nThe following example illustrates a basic use of \nZend\\Config\\Reader\\Json\n for\nloading configuration data from a JSON file.\n\n\nConsider the following JSON configuration file:\n\n\n{\n  \"webhost\"  : \"www.example.com\",\n  \"database\" : {\n    \"adapter\" : \"pdo_mysql\",\n    \"params\"  : {\n      \"host\"     : \"db.example.com\",\n      \"username\" : \"dbuser\",\n      \"password\" : \"secret\",\n      \"dbname\"   : \"dbproduction\"\n    }\n  }\n}\n\n\n\nWe can use \nZend\\Config\\Reader\\Json\n to read the file:\n\n\n$reader = new Zend\\Config\\Reader\\Json();\n$data   = $reader->fromFile('/path/to/config.json');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"\n\n\n\nZend\\Config\\Reader\\Json\n utilizes \nzend-json\n.\n\n\nUsing \nZend\\Config\\Reader\\Json\n, we can include the content of a JSON file in a\nspecific JSON section or element. This is provided using the special syntax\n\n@include\n. Suppose we have a JSON file that contains only the database\nconfiguration:\n\n\n{\n  \"database\" : {\n    \"adapter\" : \"pdo_mysql\",\n    \"params\"  : {\n      \"host\"     : \"db.example.com\",\n      \"username\" : \"dbuser\",\n      \"password\" : \"secret\",\n      \"dbname\"   : \"dbproduction\"\n    }\n  }\n}\n\n\n\nNow let's include it via another configuration file:\n\n\n{\n    \"webhost\"  : \"www.example.com\",\n    \"@include\" : \"database.json\"\n}\n\n\n\nZend\\Config\\Reader\\Yaml\n\n\nZend\\Config\\Reader\\Yaml\n enables developers to consume configuration data in a\nYAML format, and read them in the application by using an array syntax. In order\nto use the YAML reader, we need to pass a callback to an external PHP library or\nuse the \nYAML PECL extension\n.\n\n\nThe following example illustrates basic usage of \nZend\\Config\\Reader\\Yaml\n,\nusing the YAML PECL extension.\n\n\nConsider the following YAML file:\n\n\nwebhost: www.example.com\ndatabase:\n    adapter: pdo_mysql\n    params:\n      host:     db.example.com\n      username: dbuser\n      password: secret\n      dbname:   dbproduction\n\n\n\nWe can use \nZend\\Config\\Reader\\Yaml\n to read this YAML file:\n\n\n$reader = new Zend\\Config\\Reader\\Yaml();\n$data   = $reader->fromFile('/path/to/config.yaml');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"\n\n\n\nIf you want to use an external YAML reader, you must pass a callback function to\nthe class constructor.  For instance, if you want to use the\n\nSpyc\n library:\n\n\n// include the Spyc library\nrequire_once 'path/to/spyc.php';\n\n$reader = new Zend\\Config\\Reader\\Yaml(['Spyc', 'YAMLLoadString']);\n$data   = $reader->fromFile('/path/to/config.yaml');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"\n\n\n\nYou can also instantiate \nZend\\Config\\Reader\\Yaml\n without any parameters, and\nspecify the YAML reader using the \nsetYamlDecoder()\n method.\n\n\nUsing \nZend\\Config\\ReaderYaml\n, we can include the content of another YAML file\nin a specific YAML section or element. This is provided using the special syntax\n\n@include\n.\n\n\nConsider the following YAML file containing only database configuration:\n\n\ndatabase:\n    adapter: pdo_mysql\n    params:\n      host:     db.example.com\n      username: dbuser\n      password: secret\n      dbname:   dbproduction\n\n\n\nWe can include this configuration in another YAML file:\n\n\nwebhost:  www.example.com\n@include: database.yaml\n\n\n\nZend\\Config\\Reader\\JavaProperties\n\n\nZend\\Config\\Reader\\JavaProperties\n enables developers to provide configuration\ndata in the popular JavaProperties format, and read it in the application by\nusing array syntax.\n\n\nThe following example illustrates basic usage of \nZend\\Config\\Reader\\JavaProperties\n\nfor loading configuration data from a JavaProperties file.\n\n\nSuppose we have the following JavaProperties configuration file:\n\n\n#comment\n!comment\nwebhost:www.example.com\ndatabase.adapter:pdo_mysql\ndatabase.params.host:db.example.com\ndatabase.params.username:dbuser\ndatabase.params.password:secret\ndatabase.params.dbname:dbproduction\n\n\n\nWe can use \nZend\\Config\\Reader\\JavaProperties\n to read it:\n\n\n$reader = new Zend\\Config\\Reader\\JavaProperties();\n$data   = $reader->fromFile('/path/to/config.properties');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database.params.dbname'];  // prints \"dbproduction\"",
            "title": "Zend\\Config\\Reader"
        },
        {
            "location": "/reader/#zend92config92reader",
            "text": "Zend\\Config\\Reader  gives you the ability to read a config file. It works with\nconcrete implementations for different file formats.  Zend\\Config\\Reader  itself\nis only an interface, defining the methods  fromFile()  and  fromString() . The\nconcrete implementations of this interface are:   Zend\\Config\\Reader\\Ini  Zend\\Config\\Reader\\Xml  Zend\\Config\\Reader\\Json  Zend\\Config\\Reader\\Yaml  Zend\\Config\\Reader\\JavaProperties   fromFile()  and  fromString()  are expected to return a PHP array containing\nthe data from the specified configuration.",
            "title": "Zend\\Config\\Reader"
        },
        {
            "location": "/reader/#differences-from-zf1",
            "text": "The  Zend\\Config\\Reader  component no longer supports the following features:   Inheritance of sections.  Reading of specific sections.",
            "title": "Differences from ZF1"
        },
        {
            "location": "/reader/#zend92config92reader92ini",
            "text": "Zend\\Config\\Reader\\Ini  enables developers to store configuration data in a\nfamiliar INI format, and then to read them in the application by using an array\nsyntax.  Zend\\Config\\Reader\\Ini  utilizes the  parse_ini_file()  PHP\nfunction. Please review this documentation to be aware of its specific behaviors, which propagate to Zend\\Config\\Reader\\Ini , such as how the special values of  TRUE ,  FALSE , \"yes\", \"no\", and NULL  are handled.",
            "title": "Zend\\Config\\Reader\\Ini"
        },
        {
            "location": "/reader/#key-separator",
            "text": "By default, the key separator character is the period character ( . ). This can be changed,\nhowever, using the  setNestSeparator()  method. For example:  $reader = new Zend\\Config\\Reader\\Ini();\n$reader-setNestSeparator('-');   The following example illustrates basic usage of  Zend\\Config\\Reader\\Ini  for\nloading configuration data from an INI file. In this example, configuration data\nfor both a production system and for a staging system exists.  webhost                  = 'www.example.com'\ndatabase.adapter         = 'pdo_mysql'\ndatabase.params.host     = 'db.example.com'\ndatabase.params.username = 'dbuser'\ndatabase.params.password = 'secret'\ndatabase.params.dbname   = 'dbproduction'  We can use  Zend\\Config\\Reader\\Ini  to read this INI file:  $reader = new Zend\\Config\\Reader\\Ini();\n$data   = $reader->fromFile('/path/to/config.ini');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"  Zend\\Config\\Reader\\Ini  supports a feature to include the content of a INI file\nin a specific section of another INI file. For instance, suppose we have an INI\nfile with the database configuration:  database.adapter         = 'pdo_mysql'\ndatabase.params.host     = 'db.example.com'\ndatabase.params.username = 'dbuser'\ndatabase.params.password = 'secret'\ndatabase.params.dbname   = 'dbproduction'  We can include this configuration in another INI file by using the  @include \nnotation:  webhost  = 'www.example.com'\n@include = 'database.ini'  If we read this file using the component  Zend\\Config\\Reader\\Ini , we will obtain the same\nconfiguration data structure as in the previous example.  The  @include = 'file-to-include.ini'  notation can be used also in a subelement\nof a value. For instance we can have an INI file like the following:  adapter         = 'pdo_mysql'\nparams.host     = 'db.example.com'\nparams.username = 'dbuser'\nparams.password = 'secret'\nparams.dbname   = 'dbproduction'  And assign the  @include  as a subelement of the  database  value:  webhost           = 'www.example.com'\ndatabase.@include = 'database.ini'",
            "title": "Key Separator"
        },
        {
            "location": "/reader/#zend92config92reader92xml",
            "text": "Zend\\Config\\Reader\\Xml  enables developers to provide configuration data in a\nfamiliar XML format and consume it in the application using an array syntax.\nThe root element of the XML file or string is irrelevant and may be named\narbitrarily.  The following example illustrates basic usage of  Zend\\Config\\Reader\\Xml  for loading configuration\ndata from an XML file. First, our XML configuration in the file  config.xml :  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<config>\n    <webhost>www.example.com</webhost>\n    <database>\n        <adapter value=\"pdo_mysql\"/>\n        <params>\n            <host value=\"db.example.com\"/>\n            <username value=\"dbuser\"/>\n            <password value=\"secret\"/>\n            <dbname value=\"dbproduction\"/>\n        </params>\n    </database>\n</config>  We can use the  Zend\\Config\\Reader\\Xml  to read the XML configuration:  $reader = new Zend\\Config\\Reader\\Xml();\n$data   = $reader->fromFile('/path/to/config.xml');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname']['value'];  // prints \"dbproduction\"  Zend\\Config\\Reader\\Xml  utilizes PHP's  XMLReader  class. Please\nreview its documentation to be aware of its specific behaviors, which propagate to Zend\\Config\\Reader\\Xml .  Using  Zend\\Config\\Reader\\Xml , we can include the content of XML files in a\nspecific XML element.  This is provided using the standard XInclude  functionality of XML. To use this\nfunctionality, you must add the namespace xmlns:xi=\"http://www.w3.org/2001/XInclude\"  to the XML file.  Suppose we have an XML file that contains only the database configuration:  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<config>\n    <database>\n        <adapter>pdo_mysql</adapter>\n        <params>\n            <host>db.example.com</host>\n            <username>dbuser</username>\n            <password>secret</password>\n            <dbname>dbproduction</dbname>\n        </params>\n    </database>\n</config>  We can include this configuration in another XML file using an xinclude:  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<config xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n    <webhost>www.example.com</webhost>\n    <xi:include href=\"database.xml\"/>\n</config>  The syntax to include an XML file in a specific element is  <xi:include\nhref=\"file-to-include.xml\"/>",
            "title": "Zend\\Config\\Reader\\Xml"
        },
        {
            "location": "/reader/#zend92config92reader92json",
            "text": "Zend\\Config\\Reader\\Json  enables developers to consume configuration data in\nJSON, and read it in the application by using an array syntax.  The following example illustrates a basic use of  Zend\\Config\\Reader\\Json  for\nloading configuration data from a JSON file.  Consider the following JSON configuration file:  {\n  \"webhost\"  : \"www.example.com\",\n  \"database\" : {\n    \"adapter\" : \"pdo_mysql\",\n    \"params\"  : {\n      \"host\"     : \"db.example.com\",\n      \"username\" : \"dbuser\",\n      \"password\" : \"secret\",\n      \"dbname\"   : \"dbproduction\"\n    }\n  }\n}  We can use  Zend\\Config\\Reader\\Json  to read the file:  $reader = new Zend\\Config\\Reader\\Json();\n$data   = $reader->fromFile('/path/to/config.json');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"  Zend\\Config\\Reader\\Json  utilizes  zend-json .  Using  Zend\\Config\\Reader\\Json , we can include the content of a JSON file in a\nspecific JSON section or element. This is provided using the special syntax @include . Suppose we have a JSON file that contains only the database\nconfiguration:  {\n  \"database\" : {\n    \"adapter\" : \"pdo_mysql\",\n    \"params\"  : {\n      \"host\"     : \"db.example.com\",\n      \"username\" : \"dbuser\",\n      \"password\" : \"secret\",\n      \"dbname\"   : \"dbproduction\"\n    }\n  }\n}  Now let's include it via another configuration file:  {\n    \"webhost\"  : \"www.example.com\",\n    \"@include\" : \"database.json\"\n}",
            "title": "Zend\\Config\\Reader\\Json"
        },
        {
            "location": "/reader/#zend92config92reader92yaml",
            "text": "Zend\\Config\\Reader\\Yaml  enables developers to consume configuration data in a\nYAML format, and read them in the application by using an array syntax. In order\nto use the YAML reader, we need to pass a callback to an external PHP library or\nuse the  YAML PECL extension .  The following example illustrates basic usage of  Zend\\Config\\Reader\\Yaml ,\nusing the YAML PECL extension.  Consider the following YAML file:  webhost: www.example.com\ndatabase:\n    adapter: pdo_mysql\n    params:\n      host:     db.example.com\n      username: dbuser\n      password: secret\n      dbname:   dbproduction  We can use  Zend\\Config\\Reader\\Yaml  to read this YAML file:  $reader = new Zend\\Config\\Reader\\Yaml();\n$data   = $reader->fromFile('/path/to/config.yaml');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"  If you want to use an external YAML reader, you must pass a callback function to\nthe class constructor.  For instance, if you want to use the Spyc  library:  // include the Spyc library\nrequire_once 'path/to/spyc.php';\n\n$reader = new Zend\\Config\\Reader\\Yaml(['Spyc', 'YAMLLoadString']);\n$data   = $reader->fromFile('/path/to/config.yaml');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database']['params']['dbname'];  // prints \"dbproduction\"  You can also instantiate  Zend\\Config\\Reader\\Yaml  without any parameters, and\nspecify the YAML reader using the  setYamlDecoder()  method.  Using  Zend\\Config\\ReaderYaml , we can include the content of another YAML file\nin a specific YAML section or element. This is provided using the special syntax @include .  Consider the following YAML file containing only database configuration:  database:\n    adapter: pdo_mysql\n    params:\n      host:     db.example.com\n      username: dbuser\n      password: secret\n      dbname:   dbproduction  We can include this configuration in another YAML file:  webhost:  www.example.com\n@include: database.yaml",
            "title": "Zend\\Config\\Reader\\Yaml"
        },
        {
            "location": "/reader/#zend92config92reader92javaproperties",
            "text": "Zend\\Config\\Reader\\JavaProperties  enables developers to provide configuration\ndata in the popular JavaProperties format, and read it in the application by\nusing array syntax.  The following example illustrates basic usage of  Zend\\Config\\Reader\\JavaProperties \nfor loading configuration data from a JavaProperties file.  Suppose we have the following JavaProperties configuration file:  #comment\n!comment\nwebhost:www.example.com\ndatabase.adapter:pdo_mysql\ndatabase.params.host:db.example.com\ndatabase.params.username:dbuser\ndatabase.params.password:secret\ndatabase.params.dbname:dbproduction  We can use  Zend\\Config\\Reader\\JavaProperties  to read it:  $reader = new Zend\\Config\\Reader\\JavaProperties();\n$data   = $reader->fromFile('/path/to/config.properties');\n\necho $data['webhost'];  // prints \"www.example.com\"\necho $data['database.params.dbname'];  // prints \"dbproduction\"",
            "title": "Zend\\Config\\Reader\\JavaProperties"
        },
        {
            "location": "/writer/",
            "text": "Zend\\Config\\Writer\n\n\nZend\\Config\\Writer\n provides the ability to write config files from an array,\n\nZend\\Config\\Config\n instance, or any \nTraversable\n object. \nZend\\Config\\Writer\n\nis itself only an interface that defining the methods \ntoFile()\n and\n\ntoString()\n.\n\n\nWe have five writers implementing the interface:\n\n\n\n\nZend\\Config\\Writer\\Ini\n\n\nZend\\Config\\Writer\\Xml\n\n\nZend\\Config\\Writer\\PhpArray\n\n\nZend\\Config\\Writer\\Json\n\n\nZend\\Config\\Writer\\Yaml\n\n\n\n\nZend\\Config\\Writer\\Ini\n\n\nThe INI writer has two modes for rendering with regard to sections. By default, the top-level\nconfiguration is always written into section names. By calling\n\n$writer->setRenderWithoutSectionsFlags(true);\n all options are written into the global namespace of\nthe INI file and no sections are applied.\n\n\nZend\\Config\\Writer\\Ini\n has an additional option parameter, \nnestSeparator\n,\nwhich defines with which character the single nodes are separated. The default\nis a single dot (\n.\n), such as is accepted by \nZend\\Config\\Reader\\Ini\n by\ndefault.\n\n\nWhen modifying or creating a \nZend\\Config\\Config\n object, there are several\nconsiderations to keep in mind. To create or modify a value, you simply say set\nthe parameter of the \nConfig\n object via the parameter accessor (\n->\n). To\ncreate a section in the root or to create a branch, just create a new array\n(\n$config->branch = [];\n).\n\n\nUsing Zend\\Config\\Writer\\Ini\n\n\nConsider the following code, which creates a configuration structure:\n\n\n// Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Ini();\necho $writer->toString($config);\n\n\n\nThe result of this code is the following INI string:\n\n\n[production]\nwebhost = \"www.example.com\"\ndatabase.params.host = \"localhost\"\ndatabase.params.username = \"production\"\ndatabase.params.password = \"secret\"\ndatabase.params.dbname = \"dbproduction\"\n\n\n\nYou can use the method \ntoFile()\n to store the INI data to a file instead.\n\n\nZend\\Config\\Writer\\Xml\n\n\nZend\\Config\\Writer\\Xml\n can be used to generate an XML string or file.\n\n\nUsing Zend\\Config\\Writer\\Xml\n\n\nConsider the following code, which creates a configuration structure:\n\n\n// Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Xml();\necho $writer->toString($config);\n\n\n\nThe result of this code is the following XML string:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<zend-config>\n    <production>\n        <webhost>www.example.com</webhost>\n        <database>\n            <params>\n                <host>localhost</host>\n                <username>production</username>\n                <password>secret</password>\n                <dbname>dbproduction</dbname>\n            </params>\n        </database>\n    </production>\n</zend-config>\n\n\n\nYou can use the method \ntoFile()\n to store the XML data to a file.\n\n\nZend\\Config\\Writer\\PhpArray\n\n\nZend\\Config\\Writer\\PhpArray\n can be used to generate a PHP script that\nrepresents and returns configuration.\n\n\nUsing Zend\\Config\\Writer\\PhpArray\n\n\nConsider the following code, which creates a configuration structure:\n\n\n// Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\PhpArray();\necho $writer->toString($config);\n\n\n\nThe result of this code is the following PHP script:\n\n\n<?php\nreturn array (\n  'production' =>\n  array (\n    'webhost' => 'www.example.com',\n    'database' =>\n    array (\n      'params' =>\n      array (\n        'host' => 'localhost',\n        'username' => 'production',\n        'password' => 'secret',\n        'dbname' => 'dbproduction',\n      ),\n    ),\n  ),\n);\n\n\n\nYou can use the method \ntoFile()\n to save the PHP script to a file.\n\n\nZend\\Config\\Writer\\Json\n\n\nZend\\Config\\Writer\\Json\n can be used to generate a JSON representation of\nconfiguration.\n\n\nUsing Zend\\Config\\Writer\\Json\n\n\nConsider the following code, which creates a configuration structure:\n\n\n// Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Json();\necho $writer->toString($config);\n\n\n\nThe result of this code is the following JSON string:\n\n\n{\n  \"webhost\": \"www.example.com\",\n  \"database\": {\n    \"params\": {\n      \"host\": \"localhost\",\n      \"username\": \"production\",\n      \"password\": \"secret\",\n      \"dbname\": \"dbproduction\"\n    }\n  }\n}\n\n\n\nYou can use the method \ntoFile()\n to save the JSON data to a file.\n\n\nZend\\Config\\Writer\\Json\n uses the zend-json component to convert the data to\nJSON.\n\n\nZend\\Config\\Writer\\Yaml\n\n\nZend\\Config\\Writer\\Yaml\n can be used to generate a PHP code that returns the YAML\nrepresentation of configuration. In order to use the YAML writer, we need to pass a\ncallback to an external PHP library, or use the\n\nYAML PECL extension\n.\n\n\nUsing Zend\\Config\\Writer\\Yaml\n\n\nConsider the following code, which creates a configuration structure using the\nYAML PECL extension:\n\n\n// Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Yaml();\necho $writer->toString($config);\n\n\n\nThe result of this code is the following YAML string contains the following value:\n\n\nwebhost: www.example.com\ndatabase:\n    params:\n      host:     localhost\n      username: production\n      password: secret\n      dbname:   dbproduction\n\n\n\nYou can use the method \ntoFile()\n to save the YAML data to a file.\n\n\nIf you want to use an external YAML writer library, pass the callback function\nthat will generate the YAML from the configuration when instantiating the\nwriter.  For instance, to use the \nSpyc\n\nlibrary:\n\n\n// include the Spyc library\nrequire_once 'path/to/spyc.php';\n\n$writer = new Zend\\Config\\Writer\\Yaml(['Spyc', 'YAMLDump']);\necho $writer->toString($config);",
            "title": "Zend\\Config\\Writer"
        },
        {
            "location": "/writer/#zend92config92writer",
            "text": "Zend\\Config\\Writer  provides the ability to write config files from an array, Zend\\Config\\Config  instance, or any  Traversable  object.  Zend\\Config\\Writer \nis itself only an interface that defining the methods  toFile()  and toString() .  We have five writers implementing the interface:   Zend\\Config\\Writer\\Ini  Zend\\Config\\Writer\\Xml  Zend\\Config\\Writer\\PhpArray  Zend\\Config\\Writer\\Json  Zend\\Config\\Writer\\Yaml",
            "title": "Zend\\Config\\Writer"
        },
        {
            "location": "/writer/#zend92config92writer92ini",
            "text": "The INI writer has two modes for rendering with regard to sections. By default, the top-level\nconfiguration is always written into section names. By calling $writer->setRenderWithoutSectionsFlags(true);  all options are written into the global namespace of\nthe INI file and no sections are applied.  Zend\\Config\\Writer\\Ini  has an additional option parameter,  nestSeparator ,\nwhich defines with which character the single nodes are separated. The default\nis a single dot ( . ), such as is accepted by  Zend\\Config\\Reader\\Ini  by\ndefault.  When modifying or creating a  Zend\\Config\\Config  object, there are several\nconsiderations to keep in mind. To create or modify a value, you simply say set\nthe parameter of the  Config  object via the parameter accessor ( -> ). To\ncreate a section in the root or to create a branch, just create a new array\n( $config->branch = []; ).",
            "title": "Zend\\Config\\Writer\\Ini"
        },
        {
            "location": "/writer/#using-zend92config92writer92ini",
            "text": "Consider the following code, which creates a configuration structure:  // Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Ini();\necho $writer->toString($config);  The result of this code is the following INI string:  [production]\nwebhost = \"www.example.com\"\ndatabase.params.host = \"localhost\"\ndatabase.params.username = \"production\"\ndatabase.params.password = \"secret\"\ndatabase.params.dbname = \"dbproduction\"  You can use the method  toFile()  to store the INI data to a file instead.",
            "title": "Using Zend\\Config\\Writer\\Ini"
        },
        {
            "location": "/writer/#zend92config92writer92xml",
            "text": "Zend\\Config\\Writer\\Xml  can be used to generate an XML string or file.",
            "title": "Zend\\Config\\Writer\\Xml"
        },
        {
            "location": "/writer/#using-zend92config92writer92xml",
            "text": "Consider the following code, which creates a configuration structure:  // Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Xml();\necho $writer->toString($config);  The result of this code is the following XML string:  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<zend-config>\n    <production>\n        <webhost>www.example.com</webhost>\n        <database>\n            <params>\n                <host>localhost</host>\n                <username>production</username>\n                <password>secret</password>\n                <dbname>dbproduction</dbname>\n            </params>\n        </database>\n    </production>\n</zend-config>  You can use the method  toFile()  to store the XML data to a file.",
            "title": "Using Zend\\Config\\Writer\\Xml"
        },
        {
            "location": "/writer/#zend92config92writer92phparray",
            "text": "Zend\\Config\\Writer\\PhpArray  can be used to generate a PHP script that\nrepresents and returns configuration.",
            "title": "Zend\\Config\\Writer\\PhpArray"
        },
        {
            "location": "/writer/#using-zend92config92writer92phparray",
            "text": "Consider the following code, which creates a configuration structure:  // Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\PhpArray();\necho $writer->toString($config);  The result of this code is the following PHP script:  <?php\nreturn array (\n  'production' =>\n  array (\n    'webhost' => 'www.example.com',\n    'database' =>\n    array (\n      'params' =>\n      array (\n        'host' => 'localhost',\n        'username' => 'production',\n        'password' => 'secret',\n        'dbname' => 'dbproduction',\n      ),\n    ),\n  ),\n);  You can use the method  toFile()  to save the PHP script to a file.",
            "title": "Using Zend\\Config\\Writer\\PhpArray"
        },
        {
            "location": "/writer/#zend92config92writer92json",
            "text": "Zend\\Config\\Writer\\Json  can be used to generate a JSON representation of\nconfiguration.",
            "title": "Zend\\Config\\Writer\\Json"
        },
        {
            "location": "/writer/#using-zend92config92writer92json",
            "text": "Consider the following code, which creates a configuration structure:  // Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Json();\necho $writer->toString($config);  The result of this code is the following JSON string:  {\n  \"webhost\": \"www.example.com\",\n  \"database\": {\n    \"params\": {\n      \"host\": \"localhost\",\n      \"username\": \"production\",\n      \"password\": \"secret\",\n      \"dbname\": \"dbproduction\"\n    }\n  }\n}  You can use the method  toFile()  to save the JSON data to a file.  Zend\\Config\\Writer\\Json  uses the zend-json component to convert the data to\nJSON.",
            "title": "Using Zend\\Config\\Writer\\Json"
        },
        {
            "location": "/writer/#zend92config92writer92yaml",
            "text": "Zend\\Config\\Writer\\Yaml  can be used to generate a PHP code that returns the YAML\nrepresentation of configuration. In order to use the YAML writer, we need to pass a\ncallback to an external PHP library, or use the YAML PECL extension .",
            "title": "Zend\\Config\\Writer\\Yaml"
        },
        {
            "location": "/writer/#using-zend92config92writer92yaml",
            "text": "Consider the following code, which creates a configuration structure using the\nYAML PECL extension:  // Create the config object\n$config = new Zend\\Config\\Config([], true);\n$config->production = [];\n\n$config->production->webhost = 'www.example.com';\n$config->production->database = [];\n$config->production->database->params = [];\n$config->production->database->params->host = 'localhost';\n$config->production->database->params->username = 'production';\n$config->production->database->params->password = 'secret';\n$config->production->database->params->dbname = 'dbproduction';\n\n$writer = new Zend\\Config\\Writer\\Yaml();\necho $writer->toString($config);  The result of this code is the following YAML string contains the following value:  webhost: www.example.com\ndatabase:\n    params:\n      host:     localhost\n      username: production\n      password: secret\n      dbname:   dbproduction  You can use the method  toFile()  to save the YAML data to a file.  If you want to use an external YAML writer library, pass the callback function\nthat will generate the YAML from the configuration when instantiating the\nwriter.  For instance, to use the  Spyc \nlibrary:  // include the Spyc library\nrequire_once 'path/to/spyc.php';\n\n$writer = new Zend\\Config\\Writer\\Yaml(['Spyc', 'YAMLDump']);\necho $writer->toString($config);",
            "title": "Using Zend\\Config\\Writer\\Yaml"
        },
        {
            "location": "/processor/",
            "text": "Zend\\Config\\Processor\n\n\nZend\\Config\\Processor\n provides the ability to perform operations on a\n\nZend\\Config\\Config\n object. \nZend\\Config\\Processor\n is itself an interface that\ndefining two methods: \nprocess()\n and \nprocessValue()\n.\n\n\nzend-config provides the following concrete implementations:\n\n\n\n\nZend\\Config\\Processor\\Constant\n: manage PHP constant values.\n\n\nZend\\Config\\Processor\\Filter\n: filter the configuration data using \nZend\\Filter\n.\n\n\nZend\\Config\\Processor\\Queue\n: manage a queue of operations to apply to configuration data.\n\n\nZend\\Config\\Processor\\Token\n: find and replace specific tokens.\n\n\nZend\\Config\\Processor\\Translator\n: translate configuration values in other languages using \nZend\\I18n\\Translator\n.\n\n\n\n\n\n\nWhat gets processed?\n\n\nTypically, you will process configuration \nvalues\n. However, there are use\ncases for supplying constant and/or token \nkeys\n; one common one is for\nusing class-based constants as keys to avoid using magic \"strings\":\n\n\n{\n    \"Acme\\\\Compoment::CONFIG_KEY\": {}\n}\n\n\n\nAs such, as of version 3.1.0, the \nConstant\n and \nToken\n processors can\noptionally also process the keys of the \nConfig\n instance provided to them, by\ncalling \nenableKeyProcessing()\n on their instances, or passing a boolean\n\ntrue\n value for the fourth constructor argument.\n\n\n\n\nZend\\Config\\Processor\\Constant\n\n\nUsing Zend\\Config\\Processor\\Constant\n\n\nThis example illustrates the basic usage of \nZend\\Config\\Processor\\Constant\n:\n\n\ndefine ('TEST_CONST', 'bar');\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Zend\\Config\\Config(['foo' => 'TEST_CONST'], true);\n$processor = new Zend\\Config\\Processor\\Constant();\n\necho $config->foo . ',';\n$processor->process($config);\necho $config->foo;\n\n\n\nThis example returns the output: \nTEST_CONST,bar\n.\n\n\nAs of version 3.1.0, you can also tell the \nConstant\n processor to process keys:\n\n\n// At instantiation:\n$processor = new Zend\\Config\\Processor\\Constant(true, '', '', true);\n\n// Or later, via a method call:\n$processor->enableKeyProcessing();\n\n\n\nWhen enabled, any constant values found in keys will also be replaced.\n\n\nZend\\Config\\Processor\\Filter\n\n\nUsing Zend\\Config\\Processor\\Filter\n\n\nThis example illustrates basic usage of \nZend\\Config\\Processor\\Filter\n:\n\n\nuse Zend\\Filter\\StringToUpper;\nuse Zend\\Config\\Processor\\Filter as FilterProcessor;\nuse Zend\\Config\\Config;\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['foo' => 'bar'], true);\n$upper = new StringToUpper();\n\n$upperProcessor = new FilterProcessor($upper);\n\necho $config->foo . ',';\n$upperProcessor->process($config);\necho $config->foo;\n\n\n\nThis example returns the output: \nbar,BAR\n.\n\n\nZend\\Config\\Processor\\Queue\n\n\nUsing Zend\\Config\\Processor\\Queue\n\n\nThis example illustrates basic usage of \nZend\\Config\\Processor\\Queue\n:\n\n\nuse Zend\\Filter\\StringToLower;\nuse Zend\\Filter\\StringToUpper;\nuse Zend\\Config\\Processor\\Filter as FilterProcessor;\nuse Zend\\Config\\Processor\\Queue;\nuse Zend\\Config\\Config;\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['foo' => 'bar'], true);\n$upper  = new StringToUpper();\n$lower  = new StringToLower();\n\n$lowerProcessor = new FilterProcessor($lower);\n$upperProcessor = new FilterProcessor($upper);\n\n$queue = new Queue();\n$queue->insert($upperProcessor);\n$queue->insert($lowerProcessor);\n$queue->process($config);\n\necho $config->foo;\n\n\n\nThis example returns the output: \nbar\n. The filters in the queue are applied in\n\nFIFO\n (First In, First Out) order .\n\n\nZend\\Config\\Processor\\Token\n\n\nUsing Zend\\Config\\Processor\\Token\n\n\nThis example illustrates basic usage of \nZend\\Config\\Processor\\Token\n:\n\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['foo' => 'Value is TOKEN'], true);\n$processor = new TokenProcessor();\n\n$processor->addToken('TOKEN', 'bar');\necho $config->foo . ',';\n$processor->process($config);\necho $config->foo;\n\n\n\nThis example returns the output: \nValue is TOKEN,Value is bar\n.\n\n\nAs of version 3.1.0, you can also tell the \nConstant\n processor to process keys:\n\n\n// At instantiation:\n$processor = new Zend\\Config\\Processor\\Token($tokens, '', '', true);\n\n// Or later, via a method call:\n$processor->enableKeyProcessing();\n\n\n\nWhen enabled, any token values found in keys will also be replaced.\n\n\nZend\\Config\\Processor\\Translator\n\n\nUsing Zend\\Config\\Processor\\Translator\n\n\nThis example illustrates basic usage of \nZend\\Config\\Processor\\Translator\n:\n\n\nuse Zend\\Config\\Config;\nuse Zend\\Config\\Processor\\Translator as TranslatorProcessor;\nuse Zend\\I18n\\Translator\\Translator;\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['animal' => 'dog'], true);\n\n/*\n * The following mapping is used for the translation\n * loader provided to the translator instance:\n *\n * $italian = [\n *     'dog' => 'cane'\n * ];\n */\n\n$translator = new Translator();\n// ... configure the translator ...\n$processor = new TranslatorProcessor($translator);\n\necho \"English: {$config->animal}, \";\n$processor->process($config);\necho \"Italian: {$config->animal}\";\n\n\n\nThis example returns the output: \nEnglish: dog,Italian: cane\n.",
            "title": "Zend\\Config\\Processor"
        },
        {
            "location": "/processor/#zend92config92processor",
            "text": "Zend\\Config\\Processor  provides the ability to perform operations on a Zend\\Config\\Config  object.  Zend\\Config\\Processor  is itself an interface that\ndefining two methods:  process()  and  processValue() .  zend-config provides the following concrete implementations:   Zend\\Config\\Processor\\Constant : manage PHP constant values.  Zend\\Config\\Processor\\Filter : filter the configuration data using  Zend\\Filter .  Zend\\Config\\Processor\\Queue : manage a queue of operations to apply to configuration data.  Zend\\Config\\Processor\\Token : find and replace specific tokens.  Zend\\Config\\Processor\\Translator : translate configuration values in other languages using  Zend\\I18n\\Translator .",
            "title": "Zend\\Config\\Processor"
        },
        {
            "location": "/processor/#what-gets-processed",
            "text": "Typically, you will process configuration  values . However, there are use\ncases for supplying constant and/or token  keys ; one common one is for\nusing class-based constants as keys to avoid using magic \"strings\":  {\n    \"Acme\\\\Compoment::CONFIG_KEY\": {}\n}  As such, as of version 3.1.0, the  Constant  and  Token  processors can\noptionally also process the keys of the  Config  instance provided to them, by\ncalling  enableKeyProcessing()  on their instances, or passing a boolean true  value for the fourth constructor argument.",
            "title": "What gets processed?"
        },
        {
            "location": "/processor/#zend92config92processor92constant",
            "text": "",
            "title": "Zend\\Config\\Processor\\Constant"
        },
        {
            "location": "/processor/#using-zend92config92processor92constant",
            "text": "This example illustrates the basic usage of  Zend\\Config\\Processor\\Constant :  define ('TEST_CONST', 'bar');\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Zend\\Config\\Config(['foo' => 'TEST_CONST'], true);\n$processor = new Zend\\Config\\Processor\\Constant();\n\necho $config->foo . ',';\n$processor->process($config);\necho $config->foo;  This example returns the output:  TEST_CONST,bar .  As of version 3.1.0, you can also tell the  Constant  processor to process keys:  // At instantiation:\n$processor = new Zend\\Config\\Processor\\Constant(true, '', '', true);\n\n// Or later, via a method call:\n$processor->enableKeyProcessing();  When enabled, any constant values found in keys will also be replaced.",
            "title": "Using Zend\\Config\\Processor\\Constant"
        },
        {
            "location": "/processor/#zend92config92processor92filter",
            "text": "",
            "title": "Zend\\Config\\Processor\\Filter"
        },
        {
            "location": "/processor/#using-zend92config92processor92filter",
            "text": "This example illustrates basic usage of  Zend\\Config\\Processor\\Filter :  use Zend\\Filter\\StringToUpper;\nuse Zend\\Config\\Processor\\Filter as FilterProcessor;\nuse Zend\\Config\\Config;\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['foo' => 'bar'], true);\n$upper = new StringToUpper();\n\n$upperProcessor = new FilterProcessor($upper);\n\necho $config->foo . ',';\n$upperProcessor->process($config);\necho $config->foo;  This example returns the output:  bar,BAR .",
            "title": "Using Zend\\Config\\Processor\\Filter"
        },
        {
            "location": "/processor/#zend92config92processor92queue",
            "text": "",
            "title": "Zend\\Config\\Processor\\Queue"
        },
        {
            "location": "/processor/#using-zend92config92processor92queue",
            "text": "This example illustrates basic usage of  Zend\\Config\\Processor\\Queue :  use Zend\\Filter\\StringToLower;\nuse Zend\\Filter\\StringToUpper;\nuse Zend\\Config\\Processor\\Filter as FilterProcessor;\nuse Zend\\Config\\Processor\\Queue;\nuse Zend\\Config\\Config;\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['foo' => 'bar'], true);\n$upper  = new StringToUpper();\n$lower  = new StringToLower();\n\n$lowerProcessor = new FilterProcessor($lower);\n$upperProcessor = new FilterProcessor($upper);\n\n$queue = new Queue();\n$queue->insert($upperProcessor);\n$queue->insert($lowerProcessor);\n$queue->process($config);\n\necho $config->foo;  This example returns the output:  bar . The filters in the queue are applied in FIFO  (First In, First Out) order .",
            "title": "Using Zend\\Config\\Processor\\Queue"
        },
        {
            "location": "/processor/#zend92config92processor92token",
            "text": "",
            "title": "Zend\\Config\\Processor\\Token"
        },
        {
            "location": "/processor/#using-zend92config92processor92token",
            "text": "This example illustrates basic usage of  Zend\\Config\\Processor\\Token :  // Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['foo' => 'Value is TOKEN'], true);\n$processor = new TokenProcessor();\n\n$processor->addToken('TOKEN', 'bar');\necho $config->foo . ',';\n$processor->process($config);\necho $config->foo;  This example returns the output:  Value is TOKEN,Value is bar .  As of version 3.1.0, you can also tell the  Constant  processor to process keys:  // At instantiation:\n$processor = new Zend\\Config\\Processor\\Token($tokens, '', '', true);\n\n// Or later, via a method call:\n$processor->enableKeyProcessing();  When enabled, any token values found in keys will also be replaced.",
            "title": "Using Zend\\Config\\Processor\\Token"
        },
        {
            "location": "/processor/#zend92config92processor92translator",
            "text": "",
            "title": "Zend\\Config\\Processor\\Translator"
        },
        {
            "location": "/processor/#using-zend92config92processor92translator",
            "text": "This example illustrates basic usage of  Zend\\Config\\Processor\\Translator :  use Zend\\Config\\Config;\nuse Zend\\Config\\Processor\\Translator as TranslatorProcessor;\nuse Zend\\I18n\\Translator\\Translator;\n\n// Provide the second parameter as boolean true to allow modifications:\n$config = new Config(['animal' => 'dog'], true);\n\n/*\n * The following mapping is used for the translation\n * loader provided to the translator instance:\n *\n * $italian = [\n *     'dog' => 'cane'\n * ];\n */\n\n$translator = new Translator();\n// ... configure the translator ...\n$processor = new TranslatorProcessor($translator);\n\necho \"English: {$config->animal}, \";\n$processor->process($config);\necho \"Italian: {$config->animal}\";  This example returns the output:  English: dog,Italian: cane .",
            "title": "Using Zend\\Config\\Processor\\Translator"
        },
        {
            "location": "/factory/",
            "text": "The Factory\n\n\nZend\\Config\\Factory\n provides the ability to load configuration files to an\narray or to a \nZend\\Config\\Config\n object. The factory has two purposes\n\n\n\n\nLoading configuration file(s)\n\n\nStoring a configuration file\n\n\n\n\n\n\nStorage writes to a single file\n\n\nStoring the configuration always writes to a \nsingle\n file. The factory is\nnot aware of merged configuration files, and as such cannot split\nconfiguration to multiple files.  If you want to store particular\nconfiguration sections to separate files, you should separate them manually.\n\n\n\n\nLoading configuration files\n\n\nThe first example illustrates loading a single configuration file:\n\n\n// Load a PHP file as array:\n$config = Zend\\Config\\Factory::fromFile(__DIR__ . '/config/my.config.php');\n\n// Load an XML file as Config object; the second parameter, when true,\n// casts the configuration to a Config instance:\n$config = Zend\\Config\\Factory::fromFile(__DIR__.'/config/my.config.xml', true);\n\n\n\nThe next example demonstrates merging multiple files; note that they are in\nseparate formats!\n\n\n$config = Zend\\Config\\Factory::fromFiles([\n    __DIR__.'/config/my.config.php',\n    __DIR__.'/config/my.config.xml',\n]);\n\n\n\nStoring configuration\n\n\nSometimes you may want to write configuration to a file. To do this, use the\nfactory's \ntoFile()\n method:\n\n\n$config = new Zend\\Config\\Config([], true);\n$config->settings = [];\n$config->settings->myname = 'framework';\n$config->settings->date   = '2012-12-12 12:12:12';\n\n//Store the configuration\nZend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);\n\n//Store an array\n$config = [\n    'settings' => [\n        'myname' => 'framework',\n        'data'   => '2012-12-12 12:12:12',\n    ],\n];\n\nZend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);",
            "title": "Config Factory"
        },
        {
            "location": "/factory/#the-factory",
            "text": "Zend\\Config\\Factory  provides the ability to load configuration files to an\narray or to a  Zend\\Config\\Config  object. The factory has two purposes   Loading configuration file(s)  Storing a configuration file",
            "title": "The Factory"
        },
        {
            "location": "/factory/#storage-writes-to-a-single-file",
            "text": "Storing the configuration always writes to a  single  file. The factory is\nnot aware of merged configuration files, and as such cannot split\nconfiguration to multiple files.  If you want to store particular\nconfiguration sections to separate files, you should separate them manually.",
            "title": "Storage writes to a single file"
        },
        {
            "location": "/factory/#loading-configuration-files",
            "text": "The first example illustrates loading a single configuration file:  // Load a PHP file as array:\n$config = Zend\\Config\\Factory::fromFile(__DIR__ . '/config/my.config.php');\n\n// Load an XML file as Config object; the second parameter, when true,\n// casts the configuration to a Config instance:\n$config = Zend\\Config\\Factory::fromFile(__DIR__.'/config/my.config.xml', true);  The next example demonstrates merging multiple files; note that they are in\nseparate formats!  $config = Zend\\Config\\Factory::fromFiles([\n    __DIR__.'/config/my.config.php',\n    __DIR__.'/config/my.config.xml',\n]);",
            "title": "Loading configuration files"
        },
        {
            "location": "/factory/#storing-configuration",
            "text": "Sometimes you may want to write configuration to a file. To do this, use the\nfactory's  toFile()  method:  $config = new Zend\\Config\\Config([], true);\n$config->settings = [];\n$config->settings->myname = 'framework';\n$config->settings->date   = '2012-12-12 12:12:12';\n\n//Store the configuration\nZend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);\n\n//Store an array\n$config = [\n    'settings' => [\n        'myname' => 'framework',\n        'data'   => '2012-12-12 12:12:12',\n    ],\n];\n\nZend\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);",
            "title": "Storing configuration"
        },
        {
            "location": "/migration/to-v3/",
            "text": "Migration to version 3\n\n\nVersion 3 is essentially fully backwards compatible with previous versions, with\none key exception: \nZend\\Config\\Factory\n no longer requires usage of\nzend-servicemanager for resolving plugins.\n\n\nThe reason this is considered a backwards compatibility break is due to\nsignature changes:\n\n\n\n\n\n\nFactory::setReaderPluginManager()\n now accepts a\n  \nPsr\\Container\\ContainerInterface\n, and not a \nZend\\Config\\ReaderPluginManager\n\n  instance; \nReaderPluginManager\n, however, still fulfills that typehint.\n\n\n\n\n\n\nFactory::getReaderPluginManager()\n now returns a\n  \nPsr\\Container\\ContainerInterface\n \u2014 specifically, a\n  \nZend\\Config\\StandaloneReaderPluginManager\n \u2014  and not a\n  \nZend\\Config\\ReaderPluginManager\n instance, by default; \nReaderPluginManager\n,\n  however, still fulfills that typehint.\n\n\n\n\n\n\nFactory::setWriterPluginManager()\n now accepts a\n  \nPsr\\Container\\ContainerInterface\n, and not a \nZend\\Config\\WriterPluginManager\n\n  instance; \nWriterPluginManager\n, however, still fulfills that typehint.\n\n\n\n\n\n\nFactory::getWriterPluginManager()\n now returns a\n  \nPsr\\Container\\ContainerInterface\n \u2014 specifically, a\n  \nZend\\Config\\StandaloneWriterPluginManager\n \u2014  and not a\n  \nZend\\Config\\WriterPluginManager\n instance, by default; \nWriterPluginManager\n,\n  however, still fulfills that typehint.\n\n\n\n\n\n\nIf you were extending the class, you will need to update your signatures\naccordingly.\n\n\nThis particular update means that you may use any PSR-11 container as a reader\nor writer plugin manager, and no longer require installation of\nzend-servicemanager to use the plugin manager facilities.",
            "title": "To version 3"
        },
        {
            "location": "/migration/to-v3/#migration-to-version-3",
            "text": "Version 3 is essentially fully backwards compatible with previous versions, with\none key exception:  Zend\\Config\\Factory  no longer requires usage of\nzend-servicemanager for resolving plugins.  The reason this is considered a backwards compatibility break is due to\nsignature changes:    Factory::setReaderPluginManager()  now accepts a\n   Psr\\Container\\ContainerInterface , and not a  Zend\\Config\\ReaderPluginManager \n  instance;  ReaderPluginManager , however, still fulfills that typehint.    Factory::getReaderPluginManager()  now returns a\n   Psr\\Container\\ContainerInterface  \u2014 specifically, a\n   Zend\\Config\\StandaloneReaderPluginManager  \u2014  and not a\n   Zend\\Config\\ReaderPluginManager  instance, by default;  ReaderPluginManager ,\n  however, still fulfills that typehint.    Factory::setWriterPluginManager()  now accepts a\n   Psr\\Container\\ContainerInterface , and not a  Zend\\Config\\WriterPluginManager \n  instance;  WriterPluginManager , however, still fulfills that typehint.    Factory::getWriterPluginManager()  now returns a\n   Psr\\Container\\ContainerInterface  \u2014 specifically, a\n   Zend\\Config\\StandaloneWriterPluginManager  \u2014  and not a\n   Zend\\Config\\WriterPluginManager  instance, by default;  WriterPluginManager ,\n  however, still fulfills that typehint.    If you were extending the class, you will need to update your signatures\naccordingly.  This particular update means that you may use any PSR-11 container as a reader\nor writer plugin manager, and no longer require installation of\nzend-servicemanager to use the plugin manager facilities.",
            "title": "Migration to version 3"
        }
    ]
}